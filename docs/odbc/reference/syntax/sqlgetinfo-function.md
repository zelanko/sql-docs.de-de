---
title: SQLGetInfo-Funktion | Microsoft-Dokumentation
ms.custom: ''
ms.date: 05/28/2020
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLGetInfo
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLGetInfo
helpviewer_keywords:
- SQLGetInfo function [ODBC]
ms.assetid: 49dceccc-d816-4ada-808c-4c6138dccb64
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 7ce6c9e6032201f41eae058c9553f9bd61c4f079
ms.sourcegitcommit: dacd9b6f90e6772a778a3235fb69412662572d02
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 07/11/2020
ms.locfileid: "86279574"
---
# <a name="sqlgetinfo-function"></a>SQLGetInfo-Funktion

**Konformitäts**  
 Eingeführte Version: ODBC 1,0 Standards Compliance: ISO 92  
  
 **Zusammenfassung**  
 **SQLGetInfo** gibt allgemeine Informationen über den Treiber und die Datenquelle zurück, die einer Verbindung zugeordnet sind.  
  
## <a name="syntax"></a>Syntax  
  
```cpp  
  
SQLRETURN SQLGetInfo(  
     SQLHDBC         ConnectionHandle,  
     SQLUSMALLINT    InfoType,  
     SQLPOINTER      InfoValuePtr,  
     SQLSMALLINT     BufferLength,  
     SQLSMALLINT *   StringLengthPtr);  
```  
  
## <a name="arguments"></a>Argumente  

 *ConnectionHandle*  
 [Eingabe] Verbindungshandle.  
  
 *Infotype*  
 Der Informationstyp.  
  
 *Infovalueptr*  
 Ausgeben Zeiger auf einen Puffer, in den die Informationen zurückgegeben werden sollen. Abhängig vom angeforderten *InfoType* sind die zurückgegebenen Informationen eine der folgenden: eine auf NULL endende Zeichenfolge, ein sqlusmallint-Wert, eine SQLUINTEGER-Bitmaske, ein SQLUINTEGER-Flag, ein SQLUINTEGER-Binärwert oder ein SQLULEN-Wert.  
  
 Wenn das *InfoType* -Argument SQL_DRIVER_HDESC oder SQL_DRIVER_HSTMT ist, ist das *infovalueptr* -Argument sowohl Input als auch Output. (Weitere Informationen finden Sie in den SQL_DRIVER_HDESC-oder SQL_DRIVER_HSTMT Deskriptoren weiter unten in dieser Funktionsbeschreibung.)  
  
 Wenn *infovalueptr* gleich NULL ist, gibt *stringlengthptr* weiterhin die Gesamtzahl der Bytes (ausgenommen des NULL-Beendigungs Zeichens für Zeichendaten) zurück, die im Puffer zurückgegeben werden können, auf den *infovalueptr*zeigt.  
  
 *Pufferlänge*  
 Der Länge des \* *infovalueptr* -Puffers. Wenn der Wert in * \* infovalueptr* keine Zeichenfolge ist oder wenn *infovalueptr* ein NULL-Zeiger ist, wird das *BufferLength* -Argument ignoriert. Der Treiber geht davon aus, dass die Größe von * \* infovalueptr* basierend auf dem *InfoType*auf sqlusmallint oder SQLUINTEGER festgelegt ist. Wenn * \* infovalueptr* eine Unicode-Zeichenfolge ist (beim Aufrufen von **sqlgetinfow**), muss das *BufferLength* -Argument eine gerade Zahl sein. andernfalls wird SQLSTATE HY090 (ungültige Zeichen folgen-oder Pufferlänge) zurückgegeben.  
  
 *Stringlengthptr*  
 Ausgeben Ein Zeiger auf einen Puffer, in dem die Gesamtzahl der Bytes (ausgenommen des NULL-Beendigungs Zeichens für Zeichendaten) zurückgegeben werden soll, die in **infovalueptr*zurückgegeben werden können.  
  
 Wenn die Anzahl von Bytes, die für die Rückgabe verfügbar sind, größer oder gleich *BufferLength*ist, werden die Informationen in \* *infovalueptr* auf *BufferLength* -Bytes abzüglich der Länge eines NULL-Beendigungs Zeichens gekürzt und vom Treiber auf NULL-terminiert.  
  
 Für alle anderen Datentypen wird der Wert von *BufferLength* ignoriert, und der Treiber geht davon aus, dass die Größe von \* *infovalueptr* abhängig vom *InfoType*sqlusmallint oder SQLUINTEGER ist.  
  
## <a name="returns"></a>Rückgabe  

 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR oder SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnose  

 Wenn **SQLGetInfo** entweder SQL_ERROR oder SQL_SUCCESS_WITH_INFO zurückgibt, kann ein zugeordneter SQLSTATE-Wert durch Aufrufen von **SQLGetDiagRec** mit dem *Typ* SQL_HANDLE_DBC und einem *handle* von *connectionHandle*abgerufen werden. In der folgenden Tabelle sind die SQLSTATE-Werte aufgelistet, die normalerweise von **SQLGetInfo** zurückgegeben werden, und die einzelnen Werte werden im Kontext dieser Funktion erläutert. die Notation "(DM)" geht vor den Beschreibungen von Sqlstates vor, die vom Treiber-Manager zurückgegeben werden. Der Rückgabecode, der den einzelnen SQLSTATE-Werten zugeordnet ist, ist SQL_ERROR, sofern nichts anderes angegeben ist.  
  
|SQLSTATE|Fehler|Beschreibung|  
|--------------|-----------|-----------------|  
|01000|Allgemeine Warnung|Treiber spezifische Informations Meldung. (Die Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|01004|Zeichen folgen Daten, rechts abgeschnitten|Der \* *infovalueptr* -Puffer war nicht groß genug, um alle angeforderten Informationen zurückzugeben. Aus diesem Grund wurden die Informationen abgeschnitten. Die Länge der angeforderten Informationen in der nicht abgeschnittene Form wird in **stringlengthptr*zurückgegeben. (Die Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|08003|Verbindung nicht geöffnet|(DM) für den in *InfoType* angeforderten Informationstyp ist eine geöffnete Verbindung erforderlich. Von den Informationstypen, die von ODBC reserviert werden, können nur SQL_ODBC_VER ohne geöffnete Verbindung zurückgegeben werden.|  
|08S01|Kommunikations Verbindungsfehler|Die Kommunikationsverbindung zwischen dem Treiber und der Datenquelle, mit der der Treiber verbunden war, ist fehlgeschlagen, bevor die Funktion die Verarbeitung abgeschlossen hat.|  
|HY000|Allgemeiner Fehler|Es ist ein Fehler aufgetreten, bei dem kein spezifischer SQLSTATE vorhanden war und für den kein Implementierungs spezifischer SQLSTATE definiert wurde. Die von **SQLGetDiagRec** im * \* MessageText* -Puffer zurückgegebene Fehlermeldung beschreibt den Fehler und die Ursache.|  
|HY001|Fehler bei der Speicher Belegung|Der Treiber konnte keinen Arbeitsspeicher zuweisen, der zur Unterstützung der Ausführung oder Beendigung der Funktion erforderlich ist.|  
|HY010|Funktions Sequenz Fehler|(DM) **SQLExecute**, **SQLExecDirect**oder **SQLMoreResults** wurde für das *StatementHandle* aufgerufen und SQL_PARAM_DATA_AVAILABLE zurückgegeben. Diese Funktion wurde aufgerufen, bevor Daten für alle gestreuten Parameter abgerufen wurden.|  
|HY013|Speicher Verwaltungsfehler|Der Funktions Aufrufwert konnte nicht verarbeitet werden, da auf die zugrunde liegenden Speicher Objekte nicht zugegriffen werden konnte, möglicherweise aufgrund von wenig Arbeitsspeicher.|  
|HY024|Ungültiger Attribut Wert|(DM) das *InfoType* -Argument wurde SQL_DRIVER_HSTMT, und der Wert, auf den von *infovalueptr* verwiesen wird, war kein gültiges Anweisungs Handle.<br /><br /> (DM) das *InfoType* -Argument wurde SQL_DRIVER_HDESC, und der Wert, auf den von *infovalueptr* verwiesen wird, war kein gültiges Deskriptorhandle.|  
|HY090|Ungültige Zeichen folgen-oder Pufferlänge|(DM) der für das Argument *BufferLength* angegebene Wert war kleiner als 0 (null).<br /><br /> (DM) der für *BufferLength* angegebene Wert war eine ungerade Zahl, und * \* infovalueptr* war von einem Unicode-Datentyp.|  
|HY096|Informationstyp außerhalb des gültigen Bereichs|Der für den Argument *InfoType* angegebene Wert war für die Version von ODBC, die vom Treiber unterstützt wird, ungültig.|  
|HY117|Die Verbindung wurde aufgrund eines unbekannten Transaktions Zustands angehalten. Nur Disconnect-und Read-Only-Funktionen sind zulässig.|(DM) Weitere Informationen zum angehaltenen Status finden Sie unter [SQLEndTran Function](sqlendtran-function.md).|  
|HYC00|Optionales Feld nicht implementiert|Der für das Argument *InfoType* angegebene Wert war ein Treiber spezifischer Wert, der vom Treiber nicht unterstützt wird.|  
|HYT01|Verbindungs Timeout abgelaufen|Der Verbindungs Timeout Zeitraum ist abgelaufen, bevor die Datenquelle auf die Anforderung geantwortet hat. Der Timeout Zeitraum für die Verbindung wird über **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT festgelegt.|  
|IM001|Der Treiber unterstützt diese Funktion nicht.|(DM) der Treiber, der dem *connectionHandle* entspricht, unterstützt die-Funktion nicht.|  
  
## <a name="comments"></a>Kommentare  

 Die derzeit definierten Informationstypen werden in diesem Abschnitt unter "Informationstypen" angezeigt. Es wird erwartet, dass mehr Datenquellen definiert werden, um unterschiedliche Datenquellen zu nutzen. Ein Bereich von Informationstypen wird von ODBC reserviert. Treiber Entwickler müssen Werte für Ihre eigene Treiber spezifische Verwendung in der geöffneten Gruppe reservieren. **SQLGetInfo** führt keine Unicode-Konvertierung oder- *Thunking* durch (siehe [Anhang A: ODBC-Fehler Codes](../appendixes/appendix-a-odbc-error-codes.md) der *ODBC-Programmier Referenz*) für Treiber definierte *INFOTYPES*. Weitere Informationen finden Sie unter [Treiber spezifische Datentypen, deskriptortypen, Informationstypen, Diagnose Typen und Attribute](../develop-app/driver-specific-data-types-descriptor-information-diagnostic.md). Das Format der Informationen, die in \* *infovalueptr* zurückgegeben werden, hängt vom angeforderten *InfoType* ab. **SQLGetInfo** gibt Informationen in einem von fünf verschiedenen Formaten zurück:  
  
- Eine NULL terminierte Zeichenfolge.  
  
- Einen sqlusmallint-Wert  
  
- Eine SQLUINTEGER-Bitmaske  
  
- Einen SQLUINTEGER-Wert  
  
- Ein SQLUINTEGER-Binärwert  
  
 Das Format der folgenden Informationstypen wird in der Beschreibung des Typs angegeben. Die Anwendung muss den in **infovalueptr* zurückgegebenen Wert entsprechend umwandeln. Ein Beispiel dafür, wie eine Anwendung Daten aus einer SQLUINTEGER-Bitmaske abrufen kann, finden Sie unter "Code Beispiel".  
  
 Ein Treiber muss für jeden Informationstyp, der in den folgenden Tabellen definiert ist, einen Wert zurückgeben. Wenn ein Informationstyp nicht auf den Treiber oder die Datenquelle angewendet wird, gibt der Treiber einen der in der folgenden Tabelle aufgeführten Werte zurück.  

|||
|-|-|
|Zeichenfolge ("Y" oder "N")|"N"|
|Zeichenfolge (nicht "Y" oder "N")|leere Zeichenfolge|
|Sqlusmallint|0|
|SQLUINTEGER-Bitmaske oder SQLUINTEGER-Binärwert|0L|
  
 Wenn eine Datenquelle z. b. keine Prozeduren unterstützt, gibt **SQLGetInfo** die in der folgenden Tabelle aufgeführten Werte für die Werte von *InfoType* zurück, die mit Prozeduren verknüpft sind.  

|||
|-|-|
|SQL_PROCEDURES|"N"|
|SQL_ACCESSIBLE_PROCEDURES|"N"|
|SQL_MAX_PROCEDURE_NAME_LEN|0|
|SQL_PROCEDURE_TERM|leere Zeichenfolge|
  
 **SQLGetInfo** gibt SQLSTATE HY096 (Ungültiger Argument Wert) für die *InfoType* -Werte zurück, die im Bereich von Informationstypen liegen, die für die Verwendung durch ODBC reserviert sind, aber nicht durch die vom Treiber unterstützte Version von ODBC definiert sind. Um zu ermitteln, welche Version von ODBC ein Treiber erfüllt, ruft eine Anwendung **SQLGetInfo** mit dem SQL_DRIVER_ODBC_VER Informationstyp auf. **SQLGetInfo** gibt SQLSTATE HYC00 (optionales Feature nicht implementiert) für die *InfoType* -Werte zurück, die sich im Bereich von Informationstypen befinden, die für die Treiber spezifische Verwendung reserviert sind, jedoch nicht vom Treiber unterstützt werden.  
  
 Alle Aufrufe von **SQLGetInfo** erfordern eine geöffnete Verbindung, außer wenn der *InfoType* SQL_ODBC_VER ist, der die Version des Treiber-Managers zurückgibt.  
  
## <a name="information-types"></a>Informationstypen  

 In diesem Abschnitt werden die von **SQLGetInfo**unterstützten Informationstypen aufgelistet. Informationstypen werden kategorisch gruppiert und alphabetisch aufgelistet. Informationstypen, die für ODBC 3 *. x* hinzugefügt oder umbenannt wurden, werden ebenfalls aufgelistet.  
  
## <a name="driver-information"></a>Treiber Informationen  

 Die folgenden Werte des *InfoType* -Arguments geben Informationen zum ODBC-Treiber zurück, z. b. die Anzahl aktiver Anweisungen, den Datenquellen Namen und die Kompatibilitäts Ebene der Schnittstellenstandards:  
  
|||  
|-|-|  
|SQL_ACTIVE_ENVIRONMENTS|SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2|  
|SQL_ASYNC_DBC_FUNCTIONS|SQL_FILE_USAGE|  
|SQL_ASYNC_MODE|SQL_GETDATA_EXTENSIONS|  
|SQL_ASYNC_NOTIFICATION|SQL_INFO_SCHEMA_VIEWS|  
|SQL_BATCH_ROW_COUNT|SQL_KEYSET_CURSOR_ATTRIBUTES1|  
|SQL_BATCH_SUPPORT|SQL_KEYSET_CURSOR_ATTRIBUTES2|  
|SQL_DATA_SOURCE_NAME|SQL_MAX_ASYNC_CONCURRENT_STATEMENTS|  
|SQL_DRIVER_AWARE_POOLING_SUPPORTED|SQL_MAX_CONCURRENT_ACTIVITIES|  
|SQL_DRIVER_HDBC|SQL_MAX_DRIVER_CONNECTIONS|  
|SQL_DRIVER_HDESC|SQL_ODBC_INTERFACE_CONFORMANCE|  
|SQL_DRIVER_HENV|SQL_ODBC_STANDARD_CLI_CONFORMANCE|  
|SQL_DRIVER_HLIB|SQL_ODBC_VER|  
|SQL_DRIVER_HSTMT|SQL_PARAM_ARRAY_ROW_COUNTS|  
|SQL_DRIVER_NAME|SQL_PARAM_ARRAY_SELECTS|  
|SQL_DRIVER_ODBC_VER|SQL_ROW_UPDATES|  
|SQL_DRIVER_VER|SQL_SEARCH_PATTERN_ESCAPE|  
|SQL_DYNAMIC_CURSOR_ATTRIBUTES1|SQL_SERVER_NAME|  
|SQL_DYNAMIC_CURSOR_ATTRIBUTES2|SQL_STATIC_CURSOR_ATTRIBUTES1|  
|SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1|SQL_STATIC_CURSOR_ATTRIBUTES2|  
  
> [!NOTE]  
> Bei der Implementierung von **SQLGetInfo**kann ein Treiber die Leistung verbessern, indem die Anzahl der vom Server gesendeten oder angeforderten Informationen minimiert wird.  
  
## <a name="dbms-product-information"></a>DBMS-Produktinformationen  

 Die folgenden Werte des *InfoType* -Arguments geben Informationen zum DBMS-Produkt zurück, z. b. DBMS-Name und-Version:  

|||
|-|-|
|SQL_DATABASE_NAME|SQL_DBMS_NAME|
|SQL_DBMS_VER||
  
## <a name="data-source-information"></a>Datenquellen Informationen  

 Die folgenden Werte des *InfoType* -Arguments geben Informationen über die Datenquelle zurück, z. b. Cursor Merkmale und Transaktionsfunktionen:  
  
|||  
|-|-|  
|SQL_ACCESSIBLE_PROCEDURES|SQL_MULT_RESULT_SETS|  
|SQL_ACCESSIBLE_TABLES|SQL_MULTIPLE_ACTIVE_TXN|  
|SQL_BOOKMARK_PERSISTENCE|SQL_NEED_LONG_DATA_LEN|  
|SQL_CATALOG_TERM|SQL_NULL_COLLATION|  
|SQL_COLLATION_SEQ|SQL_PROCEDURE_TERM|  
|SQL_CONCAT_NULL_BEHAVIOR|SQL_SCHEMA_TERM|  
|SQL_CURSOR_COMMIT_BEHAVIOR|SQL_SCROLL_OPTIONS|  
|SQL_CURSOR_ROLLBACK_BEHAVIOR|SQL_TABLE_TERM|  
|SQL_CURSOR_SENSITIVITY|SQL_TXN_CAPABLE|  
|SQL_DATA_SOURCE_READ_ONLY|SQL_TXN_ISOLATION_OPTION|  
|SQL_DEFAULT_TXN_ISOLATION|SQL_USER_NAME|  
|SQL_DESCRIBE_PARAMETER||  
  
## <a name="supported-sql"></a>Unterstützte SQL-  

 Die folgenden Werte des *InfoType* -Arguments geben Informationen über die SQL-Anweisungen zurück, die von der Datenquelle unterstützt werden. Die SQL-Syntax der einzelnen Features, die von diesen Informationstypen beschrieben werden, ist die SQL-92-Syntax. Diese Informationstypen beschreiben nicht die gesamte SQL-92-Grammatik. Stattdessen beschreiben Sie die Teile der Grammatik, für die Datenquellen in der Regel unterschiedliche Ebenen der Unterstützung bieten. Insbesondere werden die meisten DDL-Anweisungen in SQL-92 abgedeckt.  
  
 Anwendungen sollten die allgemeine Ebene der unterstützten Grammatik aus dem SQL_SQL_CONFORMANCE Informationstyp ermitteln und die anderen Informationstypen verwenden, um Abweichungen von der angegebenen Standards-Kompatibilitäts Stufe zu ermitteln.  
  
|||  
|-|-|  
|SQL_AGGREGATE_FUNCTIONS|SQL_DROP_TABLE|  
|SQL_ALTER_DOMAIN|SQL_DROP_TRANSLATION|  
|SQL_ALTER_SCHEMA|SQL_DROP_VIEW|  
|SQL_ALTER_TABLE|SQL_EXPRESSIONS_IN_ORDERBY|  
|SQL_ANSI_SQL_DATETIME_LITERALS|SQL_GROUP_BY|  
|SQL_CATALOG_LOCATION|SQL_IDENTIFIER_CASE|  
|SQL_CATALOG_NAME|SQL_IDENTIFIER_QUOTE_CHAR|  
|SQL_CATALOG_NAME_SEPARATOR|SQL_INDEX_KEYWORDS|  
|SQL_CATALOG_USAGE|SQL_INSERT_STATEMENT|  
|SQL_COLUMN_ALIAS|SQL_INTEGRITY|  
|SQL_CORRELATION_NAME|SQL_KEYWORDS|  
|SQL_CREATE_ASSERTION|SQL_LIKE_ESCAPE_CLAUSE|  
|SQL_CREATE_CHARACTER_SET|SQL_NON_NULLABLE_COLUMNS|  
|SQL_CREATE_COLLATION|SQL_SQL_CONFORMANCE|  
|SQL_CREATE_DOMAIN|SQL_OJ_CAPABILITIES|  
|SQL_CREATE_SCHEMA|SQL_ORDER_BY_COLUMNS_IN_SELECT|  
|SQL_CREATE_TABLE|SQL_OUTER_JOINS|  
|SQL_CREATE_TRANSLATION|SQL_PROCEDURES|  
|SQL_DDL_INDEX|SQL_QUOTED_IDENTIFIER_CASE|  
|SQL_DROP_ASSERTION|SQL_SCHEMA_USAGE|  
|SQL_DROP_CHARACTER_SET|SQL_SPECIAL_CHARACTERS|  
|SQL_DROP_COLLATION|SQL_SUBQUERIES|  
|SQL_DROP_DOMAIN|SQL_UNION|  
|SQL_DROP_SCHEMA||  
  
## <a name="sql-limits"></a>SQL-Limits  

 Die folgenden Werte des *InfoType* -Arguments geben Informationen zu den Grenzwerten zurück, die auf Bezeichner und Klauseln in SQL-Anweisungen angewendet werden, z. b. die maximale Länge von bezeichnerwerten und die maximale Anzahl von Spalten in einer Auswahlliste. Einschränkungen können durch den Treiber oder die Datenquelle auferlegt werden.  
  
|||  
|-|-|  
|SQL_MAX_BINARY_LITERAL_LEN|SQL_MAX_IDENTIFIER_LEN|  
|SQL_MAX_CATALOG_NAME_LEN|SQL_MAX_INDEX_SIZE|  
|SQL_MAX_CHAR_LITERAL_LEN|SQL_MAX_PROCEDURE_NAME_LEN|  
|SQL_MAX_COLUMN_NAME_LEN|SQL_MAX_ROW_SIZE|  
|SQL_MAX_COLUMNS_IN_GROUP_BY|SQL_MAX_ROW_SIZE_INCLUDES_LONG|  
|SQL_MAX_COLUMNS_IN_INDEX|SQL_MAX_SCHEMA_NAME_LEN|  
|SQL_MAX_COLUMNS_IN_ORDER_BY|SQL_MAX_STATEMENT_LEN|  
|SQL_MAX_COLUMNS_IN_SELECT|SQL_MAX_TABLE_NAME_LEN|  
|SQL_MAX_COLUMNS_IN_TABLE|SQL_MAX_TABLES_IN_SELECT|  
|SQL_MAX_CURSOR_NAME_LEN|SQL_MAX_USER_NAME_LEN|  
  
## <a name="scalar-function-information"></a>Informationen zur Skalarfunktion  

 Die folgenden Werte des *InfoType* -Arguments geben Informationen über die skalaren Funktionen zurück, die von der Datenquelle und dem Treiber unterstützt werden. Weitere Informationen zu skalaren Funktionen finden Sie unter [Anhang E: Skalarfunktionen](../appendixes/appendix-e-scalar-functions.md).  
  
|||  
|-|-|  
|SQL_CONVERT_FUNCTIONS|SQL_TIMEDATE_ADD_INTERVALS|  
|SQL_NUMERIC_FUNCTIONS|SQL_TIMEDATE_DIFF_INTERVALS|  
|SQL_STRING_FUNCTIONS|SQL_TIMEDATE_FUNCTIONS|  
|SQL_SYSTEM_FUNCTIONS||  
  
## <a name="conversion-information"></a>Konvertierungs Informationen  

 Die folgenden Werte des *InfoType* -Arguments geben eine Liste der SQL-Datentypen zurück, in die die Datenquelle den angegebenen SQL-Datentyp mit der **Convert** -Skalarfunktion konvertieren kann:  
  
|||  
|-|-|  
|SQL_CONVERT_BIGINT|SQL_CONVERT_LONGVARBINARY|  
|SQL_CONVERT_BINARY|SQL_CONVERT_LONGVARCHAR|  
|SQL_CONVERT_BIT|SQL_CONVERT_NUMERIC|  
|SQL_CONVERT_CHAR|SQL_CONVERT_REAL|  
|SQL_CONVERT_DATE|SQL_CONVERT_SMALLINT|  
|SQL_CONVERT_DECIMAL|SQL_CONVERT_TIME|  
|SQL_CONVERT_DOUBLE|SQL_CONVERT_TIMESTAMP|  
|SQL_CONVERT_FLOAT|SQL_CONVERT_TINYINT|  
|SQL_CONVERT_INTEGER|SQL_CONVERT_VARBINARY|  
|SQL_CONVERT_INTERVAL_YEAR_MONTH|SQL_CONVERT_VARCHAR|  
|SQL_CONVERT_INTERVAL_DAY_TIME||  
  
## <a name="information-types-added-for-odbc-3x"></a>Für ODBC 3. x hinzugefügte Informationstypen  

 Die folgenden Werte des *InfoType* -Arguments wurden für ODBC 3. x hinzugefügt:  
  
|||  
|-|-|  
|SQL_ACTIVE_ENVIRONMENTS|SQL_DRIVER_AWARE_POOLING_SUPPORTED|  
|SQL_AGGREGATE_FUNCTIONS|SQL_DRIVER_HDESC|  
|SQL_ALTER_DOMAIN|SQL_DROP_ASSERTION|  
|SQL_ALTER_SCHEMA|SQL_DROP_CHARACTER_SET|  
|SQL_ANSI_SQL_DATETIME_LITERALS|SQL_DROP_COLLATION|  
|SQL_ASYNC_DBC_FUNCTIONS|SQL_DROP_DOMAIN|  
|SQL_ASYNC_MODE|SQL_DROP_SCHEMA|  
|SQL_ASYNC_NOTIFICATION|SQL_DROP_TABLE|  
|SQL_BATCH_ROW_COUNT|SQL_DROP_TRANSLATION|  
|SQL_BATCH_SUPPORT|SQL_DROP_VIEW|  
|SQL_CATALOG_NAME|SQL_DYNAMIC_CURSOR_ATTRIBUTES1|  
|SQL_COLLATION_SEQ|SQL_DYNAMIC_CURSOR_ATTRIBUTES2|  
|SQL_CONVERT_INTERVAL_YEAR_MONTH|SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1|  
|SQL_CONVERT_INTERVAL_DAY_TIME|SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2|  
|SQL_CREATE_ASSERTION|SQL_INFO_SCHEMA_VIEWS|  
|SQL_CREATE_CHARACTER_SET|SQL_INSERT_STATEMENT|  
|SQL_CREATE_COLLATION|SQL_KEYSET_CURSOR_ATTRIBUTES1|  
|SQL_CREATE_DOMAIN|SQL_KEYSET_CURSOR_ATTRIBUTES2|  
|SQL_CREATE_SCHEMA|SQL_MAX_ASYNC_CONCURRENT_STATEMENTS|  
|SQL_CREATE_TABLE|SQL_MAX_IDENTIFIER_LEN|  
|SQL_CREATE_TRANSLATION|SQL_PARAM_ARRAY_ROW_COUNTS|  
|SQL_CURSOR_SENSITIVITY|SQL_PARAM_ARRAY_SELECTS|  
|SQL_DDL_INDEX|SQL_STATIC_CURSOR_ATTRIBUTES1|  
|SQL_DESCRIBE_PARAMETER|SQL_STATIC_CURSOR_ATTRIBUTES2|  
|SQL_DM_VER|SQL_XOPEN_CLI_YEAR|  
  
## <a name="information-types-renamed-for-odbc-3x"></a>Für ODBC 3. x umbenannte Informationstypen  

 Die folgenden Werte des *InfoType* -Arguments wurden für ODBC 3. x umbenannt.  

|Alter Name|Neuer Name|  
|-|-|  
|SQL_ACTIVE_CONNECTIONS|SQL_MAX_DRIVER_CONNECTIONS|
|SQL_ACTIVE_STATEMENTS|SQL_MAX_CONCURRENT_ACTIVITIES|
|SQL_MAX_OWNER_NAME_LEN|SQL_MAX_SCHEMA_NAME_LEN|
|SQL_MAX_QUALIFIER_NAME_LEN|SQL_MAX_CATALOG_NAME_LEN|
|SQL_ODBC_SQL_OPT_IEF|SQL_INTEGRITY|
|SQL_OWNER_TERM|SQL_SCHEMA_TERM|
|SQL_OWNER_USAGE|SQL_SCHEMA_USAGE|
|SQL_QUALIFIER_LOCATION|SQL_CATALOG_LOCATION|
|SQL_QUALIFIER_NAME_SEPARATOR|SQL_CATALOG_NAME_SEPARATOR|
|SQL_QUALIFIER_TERM|SQL_CATALOG_TERM|
|SQL_QUALIFIER_USAGE|SQL_CATALOG_USAGE|
  
## <a name="information-types-deprecated-in-odbc-3x"></a>In ODBC 3. x veraltete Informationstypen  

 Die folgenden Werte des *InfoType* -Arguments wurden in ODBC 3. x als veraltet markiert. ODBC 3. x-Treiber müssen diese Informationstypen für die Abwärtskompatibilität mit ODBC 2. x-Anwendungen weiterhin unterstützen. (Weitere Informationen zu diesen Typen finden Sie [unter SQLGetInfo-Unterstützung](../appendixes/sqlgetinfo-support.md) in Anhang G: Treiber Richtlinien zur Abwärtskompatibilität.)  
  
|||  
|-|-|  
|SQL_FETCH_DIRECTION|SQL_POS_OPERATIONS|  
|SQL_LOCK_TYPES|SQL_POSITIONED_STATEMENTS|  
|SQL_ODBC_API_CONFORMANCE|SQL_SCROLL_CONCURRENCY|  
|SQL_ODBC_SQL_CONFORMANCE|SQL_STATIC_SENSITIVITY|  
  
## <a name="information-type-descriptions"></a>Beschreibungen von Informationstypen  

In der folgenden Tabelle sind die einzelnen Informationstypen, die Version von ODBC, in der Sie eingeführt wurde, und ihre Beschreibung alphabetisch aufgeführt.  
  
|Informationstyp|ODBC-Version|Beschreibung|
|-|-|-|
|SQL_ACCESSIBLE_PROCEDURES|1.0|Eine Zeichenfolge: "Y", wenn der Benutzer alle Prozeduren ausführen kann, die von **SQLProcedures**zurückgegeben werden. "N", wenn möglicherweise Prozeduren zurückgegeben werden, die der Benutzer nicht ausführen kann.|
|SQL_ACCESSIBLE_TABLES|1.0|Eine Zeichenfolge: "Y", wenn dem **Benutzer garantiert wird** , dass er Berechtigungen für alle von **SQLTables**zurückgegebenen Tabellen hat. "N", wenn möglicherweise Tabellen zurückgegeben werden, auf die der Benutzer nicht zugreifen kann.|
|SQL_ACTIVE_ENVIRONMENTS|3.0|Ein sqlusmallint-Wert, der die maximale Anzahl aktiver Umgebungen angibt, die der Treiber unterstützen kann. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.|
|SQL_AGGREGATE_FUNCTIONS|3.0|Eine SQLUINTEGER-Bitmaske, die die Unterstützung für Aggregations Funktionen aufzählt:<br/>SQL_AF_ALL<br/>SQL_AF_AVG<br/>SQL_AF_COUNT<br/>SQL_AF_DISTINCT<br/>SQL_AF_MAX<br/>SQL_AF_MIN<br/>SQL_AF_SUM<br/><br/>Ein mit SQL-92 Eintrags Level übergebender Treiber gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_ALTER_DOMAIN|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Alter Domain** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird. Ein vollständig kompatibler SQL-92-Treiber gibt immer alle Bitmasken zurück. Der Rückgabewert "0" bedeutet, dass die **Alter Domain** -Anweisung nicht unterstützt wird.<br/><br/>Die SQL-92-oder FPS-Konformitätsstufe, bei der diese Funktion unterstützt werden muss, wird in Klammern neben den einzelnen Bitmasken angezeigt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_AD_ADD_DOMAIN_CONSTRAINT = das Hinzufügen einer Domänen Einschränkung wird unterstützt (vollständig)<br/>SQL_AD_ADD_DOMAIN_DEFAULT = \<alter domain> \<set domain default clause> wird unterstützt (vollständig)<br/>SQL_AD_CONSTRAINT_NAME_DEFINITION = \<constraint name definition clause> wird für die Einschränkung der Benennungs Domäne (Zwischenebene) unterstützt.<br/>SQL_AD_DROP_DOMAIN_CONSTRAINT = \<drop domain constraint clause> wird unterstützt (vollständig)<br/>SQL_AD_DROP_DOMAIN_DEFAULT = \<alter domain> \<drop domain default clause> wird unterstützt (vollständig)<br/><br/>In den folgenden Bits wird der unterstützte angegeben, \<constraint attributes> Wenn \<add domain constraint> unterstützt wird (das SQL_AD_ADD_DOMAIN_CONSTRAINT Bit ist festgelegt):<br/>SQL_AD_ADD_CONSTRAINT_DEFERRABLE (vollständig)<br/>SQL_AD_ADD_CONSTRAINT_NON_DEFERRABLE (vollständig)<br/>SQL_AD_ADD_CONSTRAINT_INITIALLY_DEFERRED (vollständig)<br/>SQL_AD_ADD_CONSTRAINT_INITIALLY_IMMEDIATE (vollständig)|
|SQL_ALTER_TABLE|2.0|Eine SQLUINTEGER-Bitmaske, die die-Klauseln in der **ALTER TABLE** -Anweisung auflistet, die von der Datenquelle unterstützt wird.<br/><br/>Die SQL-92-oder FPS-Konformitätsstufe, bei der diese Funktion unterstützt werden muss, wird in Klammern neben den einzelnen Bitmasken angezeigt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>Die SQL_AT_ADD_COLUMN_COLLATION =- \<add column> Klausel wird unterstützt, mit der Funktion zum Angeben der Spalten Sortierung (Full Level) (ODBC 3,0).<br/>Die SQL_AT_ADD_COLUMN_DEFAULT =- \<add column> Klausel wird unterstützt, mit der Funktion zum Angeben von Spalten Standardwerten (über die Übergangsstufe "fps") (OD3,0 BC<br/>SQL_AT_ADD_COLUMN_SINGLE = \<add column> wird unterstützt (fps-Übergangs Ebene) (ODBC 3,0)<br/>Die SQL_AT_ADD_CONSTRAINT =- \<add column> Klausel wird unterstützt, mit der Funktion zum Angeben von Spalten Einschränkungen (über die Übergangsstufe "fps") (ODBC 3,0)<br/>Die SQL_AT_ADD_TABLE_CONSTRAINT =- \<add table constraint> Klausel wird unterstützt (fps-Übergangs Ebene) (ODBC 3,0).<br/>SQL_AT_CONSTRAINT_NAME_DEFINITION = \<constraint name definition> wird für das Benennen von Spalten-und Tabellen Einschränkungen (Intermediate Level) (ODBC 3,0) unterstützt.<br/>SQL_AT_DROP_COLUMN_CASCADE = \<drop column> Cascade wird unterstützt (fps-Übergangs Ebene) (ODBC 3,0)<br/>SQL_AT_DROP_COLUMN_DEFAULT = \<alter column> \<drop column default clause> wird unterstützt (Zwischenstufe) (ODBC 3,0)<br/>SQL_AT_DROP_COLUMN_RESTRICT = \<drop column> einschränken wird unterstützt (fps-Übergangsstufe) (ODBC 3,0)<br/>SQL_AT_DROP_TABLE_CONSTRAINT_CASCADE (ODBC 3,0)<br/>SQL_AT_DROP_TABLE_CONSTRAINT_RESTRICT = \<drop column> einschränken wird unterstützt (fps-Übergangsstufe) (ODBC 3,0)<br/>SQL_AT_SET_COLUMN_DEFAULT = \<alter column> \<set column default clause> wird unterstützt (Zwischenstufe) (ODBC 3,0)<br/><br/>Die folgenden Bits geben die Unterstützung an, \<constraint attributes> Wenn die Angabe von Spalten-oder Tabellen Einschränkungen unterstützt wird (das SQL_AT_ADD_CONSTRAINT Bit ist festgelegt):<br/>SQL_AT_CONSTRAINT_INITIALLY_DEFERRED (vollständig) (ODBC 3,0)<br/>SQL_AT_CONSTRAINT_INITIALLY_IMMEDIATE (vollständig) (ODBC 3,0)<br/>SQL_AT_CONSTRAINT_DEFERRABLE (vollständig) (ODBC 3,0)<br/>SQL_AT_CONSTRAINT_NON_DEFERRABLE (vollständig) (ODBC 3,0)|
|SQL_ASYNC_DBC_FUNCTIONS|3.8|Ein SQLUINTEGER-Wert, der angibt, ob der Treiberfunktionen asynchron auf dem Verbindungs Handle ausführen kann.<br/><br/>SQL_ASYNC_DBC_CAPABLE = der Treiber kann Verbindungsfunktionen asynchron ausführen.<br/>SQL_ASYNC_DBC_NOT_CAPABLE = der Treiber kann die Verbindungsfunktionen nicht asynchron ausführen.|
|SQL_ASYNC_MODE|3.0|Ein SQLUINTEGER-Wert, der die Ebene der asynchronen Unterstützung im Treiber angibt:<br/><br/>SQL_AM_CONNECTION = asynchrone Ausführung auf Verbindungs Ebene wird unterstützt. Entweder sind alle Anweisungs Handles, die einem gegebenen Verbindungs Handle zugeordnet sind, im asynchronen Modus, oder alle sind im synchronen Modus. Ein Anweisungs Handle für eine Verbindung kann sich nicht im asynchronen Modus befinden, während ein anderes Anweisungs Handle für dieselbe Verbindung im synchronen Modus ist und umgekehrt.<br/>SQL_AM_STATEMENT = asynchrone Ausführung auf Anweisungs Ebene wird unterstützt. Einige Anweisungs Handles, die einem Verbindungs Handle zugeordnet sind, können sich im asynchronen Modus befinden, während sich andere Anweisungs Handles auf derselben Verbindung im synchronen Modus befinden.<br/>SQL_AM_NONE = der asynchrone Modus wird nicht unterstützt.|
|SQL_ASYNC_NOTIFICATION|3.8|Ein SQLUINTEGER-Wert, der angibt, ob der Treiber die asynchrone Benachrichtigung unterstützt:<br/><br/>SQL_ASYNC_NOTIFICATION_CAPABLE = asynchrone Ausführungs Benachrichtigung wird vom Treiber unterstützt.<br/>SQL_ASYNC_NOTIFICATION_NOT_CAPABLE = asynchrone Ausführungs Benachrichtigung wird vom Treiber nicht unterstützt.<br/><br/>Es gibt zwei Kategorien von asynchronen ODBC-Vorgängen: asynchrone Vorgänge auf Verbindungs Ebene und asynchrone Vorgänge auf Anweisungs Ebene.  Wenn ein Treiber SQL_ASYNC_NOTIFICATION_CAPABLE zurückgibt, muss er Benachrichtigungen für alle APIs unterstützen, die er asynchron ausführen kann.|
|SQL_BATCH_ROW_COUNT|3.0|Eine SQLUINTEGER-Bitmaske, die das Verhalten des Treibers in Bezug auf die Verfügbarkeit der Zeilen Anzahl auflistet. Die folgenden Bitmasken werden in Verbindung mit dem Informationstyp verwendet:<br/><br/>SQL_BRC_ROLLED_UP = die Zeilen Anzahl für aufeinander folgende INSERT-, DELETE-oder Update-Anweisungen werden in einen Rollup ausgeführt. Wenn dieses Bit nicht festgelegt ist, sind die Zeilen Anzahl für jede Anweisung verfügbar.<br/>SQL_BRC_PROCEDURES = die Zeilen Anzahl, sofern vorhanden, sind verfügbar, wenn ein Batch in einer gespeicherten Prozedur ausgeführt wird. Wenn die Anzahl der Zeilen verfügbar ist, können Sie je nach SQL_BRC_ROLLED_UP Bit ein Rollup oder eine individuelle Verfügbarkeit durchgeführt werden.<br/>SQL_BRC_EXPLICIT = Zeilen Anzahl, sofern vorhanden, sind verfügbar, wenn ein Batch direkt durch Aufrufen von **SQLExecute** oder **SQLExecDirect**ausgeführt wird. Wenn die Anzahl der Zeilen verfügbar ist, können Sie je nach SQL_BRC_ROLLED_UP Bit ein Rollup oder eine individuelle Verfügbarkeit durchgeführt werden.|
|SQL_BATCH_SUPPORT|3.0|Eine SQLUINTEGER-Bitmaske, die die Unterstützung für Batches des Treibers auflistet. Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Ebene unterstützt wird:<br/><br/>SQL_BS_SELECT_EXPLICIT = der Treiber unterstützt explizite Batches, die Resultset-Generierungs Anweisungen aufweisen können.<br/>SQL_BS_ROW_COUNT_EXPLICIT = der Treiber unterstützt explizite Batches, die Anweisungen zum Erstellen von Zeilen Anzahl haben können.<br/>SQL_BS_SELECT_PROC = der Treiber unterstützt explizite Prozeduren, die Resultset-Generierungs Anweisungen aufweisen können.<br/>SQL_BS_ROW_COUNT_PROC = der Treiber unterstützt explizite Prozeduren, die Anweisungen zum Erstellen von Zeilen Anzahl aufweisen können.|
|SQL_BOOKMARK_PERSISTENCE|2.0|Eine SQLUINTEGER-Bitmaske, die die Vorgänge auflistet, über die Lesezeichen persistent gespeichert werden. Die folgenden Bitmasken werden mit dem-Flag verwendet, um zu bestimmen, welche Optionen Lesezeichen beibehalten:<br/><br/>SQL_BP_CLOSE = Lesezeichen sind gültig, nachdem eine Anwendung **SQLFreeStmt** mit der SQL_CLOSE-Option oder **SQLCloseCursor** aufgerufen hat, um den mit einer Anweisung verknüpften Cursor zu schließen.<br/>SQL_BP_DELETE = das Lesezeichen für eine Zeile ist gültig, nachdem diese Zeile gelöscht wurde.<br/>SQL_BP_DROP = Lesezeichen sind gültig, nachdem eine Anwendung **SQLFreeHandle** mit dem *Handlertyp* SQL_HANDLE_STMT aufgerufen hat, um eine Anweisung zu löschen.<br/>SQL_BP_TRANSACTION = Lesezeichen sind gültig, nachdem eine Anwendung einen Commit oder Rollback für eine Transaktion ausgeführt hat.<br/>SQL_BP_UPDATE = das Lesezeichen für eine Zeile ist gültig, nachdem alle Spalten in dieser Zeile aktualisiert wurden, einschließlich Schlüssel Spalten.<br/>SQL_BP_OTHER_HSTMT = ein Lesezeichen, das einer Anweisung zugeordnet ist, kann mit einer anderen Anweisung verwendet werden. Wenn SQL_BP_CLOSE oder SQL_BP_DROP nicht angegeben wird, muss der Cursor für die erste Anweisung geöffnet sein.|
|SQL_CATALOG_LOCATION|2.0|Ein sqlusmallint-Wert, der die Position des Katalogs in einem qualifizierten Tabellennamen angibt:<br/><br/>SQL_CL_START<br/>SQL_CL_END<br/>Ein xbase-Treiber gibt z. b. SQL_CL_START zurück, da sich der Verzeichnisname (Katalog Name) am Anfang des Tabellennamens befindet, wie in \empdata\emp. DBF. Ein Oracle-Server Treiber gibt SQL_CL_END zurück, da sich der Katalog am Ende des Tabellennamens befindet, wie in ADMIN.EMP@EMPDATA .<br/><br/>Ein vollständig konformen SQL-92-Treiber gibt immer SQL_CL_START zurück. Der Wert 0 wird zurückgegeben, wenn Kataloge von der Datenquelle nicht unterstützt werden. Um zu ermitteln, ob Kataloge unterstützt werden, ruft eine Anwendung **SQLGetInfo** mit dem SQL_CATALOG_NAME Informationstyp auf.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_QUALIFIER_LOCATION ODBC 2,0 umbenannt.|
|SQL_CATALOG_NAME|3.0|Eine Zeichenfolge: "Y", wenn der Server Katalognamen unterstützt, oder "N", wenn dies nicht der Fall ist.<br/><br/>Ein vollständig konformitäteter SQL-92-Treiber gibt immer "Y" zurück.|
|SQL_CATALOG_NAME_SEPARATOR|1.0|Eine Zeichenfolge: das Zeichen oder die Zeichen, die von der Datenquelle als Trennzeichen zwischen einem Katalognamen und dem qualifizierten Namenselement definiert werden, das folgt bzw. diesem vorangestellt ist.<br/><br/>Eine leere Zeichenfolge wird zurückgegeben, wenn Kataloge von der Datenquelle nicht unterstützt werden. Um zu ermitteln, ob Kataloge unterstützt werden, ruft eine Anwendung **SQLGetInfo** mit dem SQL_CATALOG_NAME Informationstyp auf. Ein vollständig konformen SQL-92-Treiber gibt immer "." zurück.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_QUALIFIER_NAME_SEPARATOR ODBC 2,0 umbenannt.|
|SQL_CATALOG_TERM|1.0|Eine Zeichenfolge mit dem Namen des Datenquellen Herstellers für einen Katalog. Beispiel: "Database" oder "Directory". Diese Zeichenfolge kann groß, klein oder gemischt sein.<br/><br/>Eine leere Zeichenfolge wird zurückgegeben, wenn Kataloge von der Datenquelle nicht unterstützt werden. Um zu ermitteln, ob Kataloge unterstützt werden, ruft eine Anwendung **SQLGetInfo** mit dem SQL_CATALOG_NAME Informationstyp auf. Ein vollständig konformitäteter SQL-92-Treiber gibt immer "catalog" zurück.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_QUALIFIER_TERM ODBC 2,0 umbenannt.|
|SQL_CATALOG_USAGE|2.0|Eine SQLUINTEGER-Bitmaske, die die-Anweisungen auflistet, in denen Kataloge verwendet werden können.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, wo Kataloge verwendet werden können:<br/>SQL_CU_DML_STATEMENTS = Kataloge werden in allen Anweisungen für die Daten Bearbeitungs Sprache unterstützt: **Select**, **Insert**, **Update**, **Delete**und falls unterstützt, **Wählen Sie für Update** -und positionierte UPDATE-und DELETE-Anweisungen aus.<br/>SQL_CU_PROCEDURE_INVOCATION = Kataloge werden in der Anweisung "ODBC Procedure invoation" unterstützt.<br/>SQL_CU_TABLE_DEFINITION = Kataloge werden in allen Tabellen Definitions Anweisungen unterstützt: **CREATE TABLE**, **CREATE VIEW**, **ALTER TABLE**, **DROP TABLE**und **Drop View**.<br/>SQL_CU_INDEX_DEFINITION = Kataloge werden in allen Index Definitions Anweisungen unterstützt: **Create Index** und **Drop Index**.<br/>SQL_CU_PRIVILEGE_DEFINITION = Kataloge werden in allen Berechtigungs Definitions Anweisungen unterstützt: **Grant** und **Widerruf**.<br/><br/>Der Wert 0 wird zurückgegeben, wenn Kataloge von der Datenquelle nicht unterstützt werden. Um zu ermitteln, ob Kataloge unterstützt werden, ruft eine Anwendung **SQLGetInfo** mit dem SQL_CATALOG_NAME Informationstyp auf. Ein vollständig konformen SQL-92-Treiber gibt immer eine Bitmaske zurück, bei der alle diese Bits festgelegt sind.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_QUALIFIER_USAGE ODBC 2,0 umbenannt.|
|SQL_COLLATION_SEQ|3.0|Der Name der Sortierreihenfolge. Dies ist eine Zeichenfolge, die den Namen der Standardsortierung für den Standardzeichensatz für diesen Server angibt (z. b. "ISO 8859-1" oder EBCDIC). Wenn dies unbekannt ist, wird eine leere Zeichenfolge zurückgegeben. Ein vollständig konformen SQL-92-Treiber gibt immer eine nicht leere Zeichenfolge zurück.|
|SQL_COLUMN_ALIAS|2.0|Eine Zeichenfolge: "Y", wenn die Datenquelle Spalten Aliase unterstützt. andernfalls "N".<br/><br/>Ein Spaltenalias ist ein alternativer Name, der für eine Spalte in der Auswahlliste mit einer As-Klausel angegeben werden kann. Ein mit SQL-92 Entry Level-konformitäger Treiber gibt immer "Y" zurück.|
|SQL_CONCAT_NULL_BEHAVIOR|1.0|Ein sqlusmallint-Wert, der angibt, wie die Datenquelle die Verkettung von Spalten mit NULL-Wert-Zeichen Datentypen mit nicht-NULL-Zeichen Datentyp Spalten behandelt:<br/>SQL_CB_NULL = Ergebnis ist NULL-Wert.<br/>SQL_CB_NON_NULL = Ergebnis ist die Verkettung von nicht-NULL-Wert Spalten oder-Spalten.<br/><br/>Ein mit SQL-92 Entry Level-konformitäer Treibers gibt immer SQL_CB_NULL zurück.|
|SQL_CONVERT_BIGINT<br/>SQL_CONVERT_BINARY<br/>SQL_CONVERT_BIT<br/>SQL_CONVERT_CHAR<br/>SQL_CONVERT_GUID<br/>SQL_CONVERT_DATE<br/>SQL_CONVERT_DECIMAL<br/>SQL_CONVERT_DOUBLE<br/>SQL_CONVERT_FLOAT<br/>SQL_CONVERT_INTEGER<br/>SQL_CONVERT_INTERVAL_YEAR_MONTH<br/>SQL_CONVERT_INTERVAL_DAY_TIME<br/>SQL_CONVERT_LONGVARBINARY<br/>SQL_CONVERT_LONGVARCHAR<br/>SQL_CONVERT_NUMERIC<br/>SQL_CONVERT_REAL<br/>SQL_CONVERT_SMALLINT<br/>SQL_CONVERT_TIME<br/>SQL_CONVERT_TIMESTAMP<br/>SQL_CONVERT_TINYINT<br/>SQL_CONVERT_VARBINARY<br/>SQL_CONVERT_VARCHAR|1.0|Eine SQLUINTEGER-Bitmaske. Die Bitmaske gibt die von der Datenquelle unterstützten Konvertierungen mit der **Convert** skalare-Funktion für Daten des Typs an, der im *InfoType*benannt ist. Wenn die Bitmaske gleich 0 (null) ist, unterstützt die Datenquelle keine Konvertierungen von Daten des benannten Typs, einschließlich der Konvertierung in denselben Datentyp.<br/><br/>Um z. b. zu ermitteln, ob eine Datenquelle die Konvertierung von SQL_INTEGER Daten in den SQL_BIGINT-Datentyp unterstützt, ruft eine Anwendung **SQLGetInfo** mit dem *InfoType* SQL_CONVERT_INTEGER auf. Die Anwendung führt eine **and-** Operation mit der zurückgegebenen Bitmaske und SQL_CVT_BIGINT aus. Wenn der resultierende Wert ungleich 0 (null) ist, wird die Konvertierung unterstützt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Konvertierungen unterstützt werden:<br/>SQL_CVT_BIGINT (ODBC 1,0)<br/>SQL_CVT_BINARY (ODBC 1,0)<br/>SQL_CVT_BIT (ODBC 1,0)<br/>SQL_CVT_GUID (ODBC 3,5)<br/>SQL_CVT_CHAR (ODBC 1,0)<br/>SQL_CVT_DATE (ODBC 1,0)<br/>SQL_CVT_DECIMAL (ODBC 1,0)<br/>SQL_CVT_DOUBLE (ODBC 1,0)<br/>SQL_CVT_FLOAT (ODBC 1,0)<br/>SQL_CVT_INTEGER (ODBC 1,0)<br/>SQL_CVT_INTERVAL_YEAR_MONTH (ODBC 3,0)<br/>SQL_CVT_INTERVAL_DAY_TIME (ODBC 3,0)<br/>SQL_CVT_LONGVARBINARY (ODBC 1,0)<br/>SQL_CVT_LONGVARCHAR (ODBC 1,0)<br/>SQL_CVT_NUMERIC (ODBC 1,0)<br/>SQL_CVT_REAL (ODBC 1,0)<br/>SQL_CVT_SMALLINT (ODBC 1,0)<br/>SQL_CVT_TIME (ODBC 1,0)<br/>SQL_CVT_TIMESTAMP (ODBC 1,0)<br/>SQL_CVT_TINYINT (ODBC 1,0)<br/>SQL_CVT_VARBINARY (ODBC 1,0)<br/>SQL_CVT_VARCHAR (ODBC 1,0)|
|SQL_CONVERT_FUNCTIONS|1.0|Eine SQLUINTEGER-Bitmaske, die die vom Treiber und der zugeordneten Datenquelle unterstützten skalarkonvertierungs Funktionen auflistet.<br/><br/>Die folgende Bitmaske wird verwendet, um zu bestimmen, welche Konvertierungs Funktionen unterstützt werden:<br/>SQL_FN_CVT_CASTSQL_FN_CVT_CONVERT|
|SQL_CORRELATION_NAME|1.0|Ein sqlusmallint-Wert, der angibt, ob Tabellen Korrelations Namen unterstützt werden:<br/>SQL_CN_NONE = Korrelations Namen werden nicht unterstützt.<br/>SQL_CN_DIFFERENT = Korrelations Namen werden unterstützt, müssen sich jedoch von den Namen der Tabellen unterscheiden, die Sie darstellen.<br/>SQL_CN_ANY = Korrelations Namen werden unterstützt und können ein beliebiger gültiger benutzerdefinierter Name sein.<br/><br/>Ein mit SQL-92 Entry Level-konformitäer Treibers gibt immer SQL_CN_ANY zurück.|
|SQL_CREATE_ASSERTION|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Create** Assert-Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_CA_CREATE_ASSERTION<br/><br/>Die folgenden Bits geben das unterstützte Einschränkungs Attribut an, wenn die Möglichkeit zum expliziten Angeben von Einschränkungs Attributen unterstützt wird (siehe SQL_ALTER_TABLE-und SQL_CREATE_TABLE-Informationstypen):<br/>SQL_CA_CONSTRAINT_INITIALLY_DEFERRED<br/>SQL_CA_CONSTRAINT_INITIALLY_IMMEDIATE<br/>SQL_CA_CONSTRAINT_DEFERRABLE<br/>SQL_CA_CONSTRAINT_NON_DEFERRABLE<br/><br/>Ein vollständig konformen SQL-92-Treiber gibt immer alle diese Optionen zurück, die unterstützt werden. Der Rückgabewert "0" bedeutet, dass die **Create** Assert-Anweisung nicht unterstützt wird.|
|SQL_CREATE_CHARACTER_SET|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Create Character Set** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_CCS_CREATE_CHARACTER_SET<br/>SQL_CCS_COLLATE_CLAUSE<br/>SQL_CCS_LIMITED_COLLATION<br/><br/>Ein vollständig konformen SQL-92-Treiber gibt immer alle diese Optionen zurück, die unterstützt werden. Der Rückgabewert "0" bedeutet, dass die **Create Character Set** -Anweisung nicht unterstützt wird.|
|SQL_CREATE_COLLATION|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Create Collation** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgende Bitmaske wird verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_CCOL_CREATE_COLLATION<br/><br/>Bei einem vollständig kompatiblen SQL-92-Treiber wird diese Option immer als unterstützt zurückgegeben. Der Rückgabewert "0" bedeutet, dass die **Create COLLATIONS** -Anweisung nicht unterstützt wird.|
|SQL_CREATE_DOMAIN|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Create Domain** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_CDO_CREATE_DOMAIN = die CREATE DOMAIN-Anweisung wird unterstützt (Zwischenebene).<br/>SQL_CDO_CONSTRAINT_NAME_DEFINITION = \<constraint name definition> wird für Benennungs Domänen Einschränkungen (Zwischenebene) unterstützt.<br/><br/>Die folgenden Bits geben die Fähigkeit an, Spalten Einschränkungen zu erstellen:<br/>SQL_CDO_DEFAULT = angeben von Domänen Einschränkungen wird unterstützt (Zwischenebene)<br/>SQL_CDO_CONSTRAINT = angeben von Domänen Standardwerten wird unterstützt (Zwischenstufe)<br/>SQL_CDO_COLLATION = angeben von Domänen Sortierungen wird unterstützt (vollständig)<br/><br/>Die folgenden Bits geben die unterstützten Einschränkungs Attribute an, wenn die Angabe von Domänen Einschränkungen unterstützt wird (SQL_CDO_DEFAULT festgelegt ist)<br/>SQL_CDO_CONSTRAINT_INITIALLY_DEFERRED (vollständig)<br/>SQL_CDO_CONSTRAINT_INITIALLY_IMMEDIATE (vollständig)<br/>SQL_CDO_CONSTRAINT_DEFERRABLE (vollständig)<br/>SQL_CDO_CONSTRAINT_NON_DEFERRABLE (vollständig)<br/><br/>Der Rückgabewert "0" bedeutet, dass die **Create Domain** -Anweisung nicht unterstützt wird.|
|SQL_CREATE_SCHEMA|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Create Schema** -Anweisung auflistet, wie in SQL-92 definiert, von der Datenquelle unterstützt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_CS_CREATE_SCHEMA<br/>SQL_CS_AUTHORIZATION<br/>SQL_CS_DEFAULT_CHARACTER_SET<br/><br/>Ein SQL-92-Intermediate Level-konformitäter-Treiber gibt immer die SQL_CS_CREATE_SCHEMA-und SQL_CS_AUTHORIZATION Optionen zurück, die unterstützt werden. Diese müssen auch auf der SQL-92-Einstiegsebene unterstützt werden, jedoch nicht unbedingt als SQL-Anweisungen. Ein vollständig konformen SQL-92-Treiber gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_CREATE_TABLE|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **CREATE TABLE** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die SQL-92-oder FPS-Konformitätsstufe, bei der diese Funktion unterstützt werden muss, wird in Klammern neben den einzelnen Bitmasken angezeigt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_CT_CREATE_TABLE = die CREATE TABLE-Anweisung wird unterstützt. (Einstiegsebene)<br/>SQL_CT_TABLE_CONSTRAINT = angeben von Tabellen Einschränkungen wird unterstützt (fps-Übergangs Ebene)<br/>SQL_CT_CONSTRAINT_NAME_DEFINITION = die \<constraint name definition> -Klausel wird für das Benennen von Spalten-und Tabellen Einschränkungen (Zwischenebene) unterstützt.<br/><br/>Die folgenden Bits geben an, wie temporäre Tabellen erstellt werden können:<br/>SQL_CT_COMMIT_PRESERVE = gelöschte Zeilen werden bei Commit beibehalten. (Vollständig)<br/>SQL_CT_COMMIT_DELETE = gelöschte Zeilen werden bei Commit gelöscht. (Vollständig)<br/>SQL_CT_GLOBAL_TEMPORARY = globale temporäre Tabellen können erstellt werden. (Vollständig)<br/>SQL_CT_LOCAL_TEMPORARY = lokale temporäre Tabellen können erstellt werden. (Vollständig)<br/><br/>Die folgenden Bits geben die Fähigkeit an, Spalten Einschränkungen zu erstellen:<br/>SQL_CT_COLUMN_CONSTRAINT = angeben von Spalten Einschränkungen wird unterstützt (fps-Übergangs Ebene)<br/>SQL_CT_COLUMN_DEFAULT = angeben von Spalten Standardwerten wird unterstützt (fps-Übergangs Ebene)<br/>SQL_CT_COLUMN_COLLATION = angeben der Spalten Sortierung wird unterstützt (vollständig)<br/><br/>In den folgenden Bits werden die unterstützten Einschränkungs Attribute angegeben, wenn Spalten-oder Tabellen Einschränkungen angegeben werden:<br/>SQL_CT_CONSTRAINT_INITIALLY_DEFERRED (vollständig)<br/>SQL_CT_CONSTRAINT_INITIALLY_IMMEDIATE (vollständig)<br/>SQL_CT_CONSTRAINT_DEFERRABLE (vollständig)<br/>SQL_CT_CONSTRAINT_NON_DEFERRABLE (vollständig)|
|SQL_CREATE_TRANSLATION|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Create Translation** -Anweisung, wie in SQL-92 definiert, auflistet, die von der Datenquelle unterstützt wird.<br/><br/>Die folgende Bitmaske wird verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_CTR_CREATE_TRANSLATION<br/><br/>Ein vollständig konformen SQL-92-Treiber gibt diese Optionen immer als unterstützt zurück. Der Rückgabewert "0" bedeutet, dass die **Create Translation** -Anweisung nicht unterstützt wird.|
|SQL_CREATE_VIEW||3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **CREATE VIEW** -Anweisung, wie in SQL-92 definiert, auflistet, die von der Datenquelle unterstützt wird.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_CV_CREATE_VIEW<br/>SQL_CV_CHECK_OPTION<br/>SQL_CV_CASCADED<br/>SQL_CV_LOCAL<br/><br/>Der Rückgabewert "0" bedeutet, dass die **CREATE VIEW** -Anweisung nicht unterstützt wird.<br/><br/>Ein mit der SQL-92-Übereinstimmung übergebender Treiber gibt immer die SQL_CV_CREATE_VIEW-und SQL_CV_CHECK_OPTION Optionen zurück, die unterstützt werden.<br/><br/>Ein vollständig konformen SQL-92-Treiber gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_CURSOR_COMMIT_BEHAVIOR|1.0|Ein sqlusmallint-Wert, der angibt, wie sich ein **Commitvorgang auf** Cursor und vorbereitete Anweisungen in der Datenquelle auswirkt (das Verhalten der Datenquelle, wenn Sie einen Commit für eine Transaktion durchsetzen).<br/><br/>Der Wert dieses Attributs gibt den aktuellen Status der nächsten Einstellung an: SQL_COPT_SS_PRESERVE_CURSORS.<br/>SQL_CB_DELETE = Cursor schließen und vorbereitete Anweisungen löschen. Um den Cursor erneut zu verwenden, muss die Anwendung die Anweisung erneut vorbereiten und erneut ausführen.<br/>SQL_CB_CLOSE = schließen von Cursorn. Bei vorbereiteten Anweisungen kann die Anwendung **SQLExecute** für die Anweisung aufrufen, ohne dass **SQLPrepare** erneut aufgerufen wird. Der Standardwert für den SQL-ODBC-Treiber ist SQL_CB_CLOSE. Dies bedeutet, dass der SQL-ODBC-Treiber die Cursor schließt, wenn Sie einen Commit für eine Transaktion durchsetzen.<br/>SQL_CB_PRESERVE = Cursor an derselben Position wie **vor dem** Commitvorgang beibehalten. Die Anwendung kann weiterhin Daten abrufen, oder Sie kann den Cursor schließen und die Anweisung erneut ausführen, ohne Sie erneut vorzubereiten.|
|SQL_CURSOR_ROLLBACK_BEHAVIOR|1.0|Ein sqlusmallint-Wert, der angibt, wie sich ein **Rollback** -Vorgang auf Cursor und vorbereitete Anweisungen in der Datenquelle auswirkt:<br/>SQL_CB_DELETE = Cursor schließen und vorbereitete Anweisungen löschen. Um den Cursor erneut zu verwenden, muss die Anwendung die Anweisung erneut vorbereiten und erneut ausführen.<br/>SQL_CB_CLOSE = schließen von Cursorn. Bei vorbereiteten Anweisungen kann die Anwendung **SQLExecute** für die Anweisung aufrufen, ohne dass **SQLPrepare** erneut aufgerufen wird.<br/>SQL_CB_PRESERVE = Cursor an derselben Position wie vor dem **Rollback** -Vorgang beibehalten. Die Anwendung kann weiterhin Daten abrufen, oder Sie kann den Cursor schließen und die Anweisung erneut ausführen, ohne Sie erneut vorzubereiten.|
|SQL_CURSOR_SENSITIVITY|3.0|Ein SQLUINTEGER-Wert, der die Unterstützung der Cursor Sensitivität angibt:<br/>SQL_INSENSITIVE = alle Cursor im Anweisungs Handle zeigen das Resultset an, ohne dass Änderungen reflektiert werden, die von einem anderen Cursor innerhalb derselben Transaktion vorgenommen wurden.<br/>SQL_UNSPECIFIED = es ist nicht angegeben, ob Cursor im Anweisungs Handle die Änderungen sichtbar machen, die von einem anderen Cursor innerhalb derselben Transaktion an einem Resultset vorgenommen wurden. Cursor im Anweisungs Handle können sichtbar machen, dass keine, einige oder alle Änderungen sichtbar sind.<br/>SQL_SENSITIVE = Cursor sind von Änderungen abhängig, die von anderen Cursorn innerhalb derselben Transaktion vorgenommen wurden.<br/><br/>Ein in SQL-92 Eintrags Level übergebender Treiber gibt die SQL_UNSPECIFIED Option immer wie unterstützt zurück.<br/><br/>Ein vollständig konformen SQL-92-Treiber gibt die SQL_INSENSITIVE-Option immer wie unterstützt zurück.|
|SQL_DATA_SOURCE_NAME|1.0|Eine Zeichenfolge mit dem Datenquellen Namen, der während der Verbindung verwendet wurde. Wenn die Anwendung **SQLCONNECT**heißt, ist dies der Wert des *szdsn* -Arguments. Wenn die Anwendung **SQLDriverConnect** oder **sqlbrowseconnetct**heißt, ist dies der Wert des DSN-Schlüssel Worts in der Verbindungs Zeichenfolge, die an den Treiber weitergeleitet wird. Wenn die Verbindungs Zeichenfolge das **DSN** -Schlüsselwort nicht enthielt (z. b. Wenn Sie das **Treiber** Schlüsselwort enthält), handelt es sich um eine leere Zeichenfolge.|
|SQL_DATA_SOURCE_READ_ONLY|1.0|Eine Zeichenfolge. "Y", wenn die Datenquelle auf den schreibgeschützten Modus festgelegt ist, andernfalls "N".<br/><br/>Diese Eigenschaft bezieht sich nur auf die Datenquelle selbst. Es ist kein Merkmal des Treibers, der den Zugriff auf die Datenquelle ermöglicht. Ein Lese-/Schreibzugriff kann mit einer Datenquelle verwendet werden, die schreibgeschützt ist. Wenn ein Treiber schreibgeschützt ist, müssen alle Datenquellen schreibgeschützt sein und müssen SQL_DATA_SOURCE_READ_ONLY zurückgeben.|
|SQL_DATABASE_NAME|1.0|Eine Zeichenfolge mit dem Namen der aktuellen Datenbank, die verwendet wird, wenn die Datenquelle ein benanntes Objekt mit dem Namen "Database" definiert.<br/><br/>In ODBC 3. x kann der Wert, der für diesen *InfoType* zurückgegeben wird, auch durch Aufrufen von **SQLGetConnectAttr** mit dem *Attribut* Argument SQL_ATTR_CURRENT_CATALOG zurückgegeben werden.|
|SQL_DATETIME_LITERALS|3.0|Eine SQLUINTEGER-Bitmaske, die die SQL-92 datetime-Literale auflistet, die von der Datenquelle unterstützt werden. Beachten Sie, dass es sich hierbei um die in der SQL-92-Spezifikation aufgelisteten datetime-Literale handelt, die von ODBC definierte DateTime-literalescapeklauseln getrennt sind. Weitere Informationen zu den ODBC DateTime-literalescapeklauseln finden Sie unter [Datums-, Uhrzeit-und Timestamp-Literale](../develop-app/date-time-and-timestamp-literals.md).<br/><br/> Ein mit der Anwendung übereinstellender PPS-Operator gibt immer den Wert "1" in der Bitmaske für die Bits in der folgenden Liste zurück. Der Wert "0" bedeutet, dass SQL-92 datetime-Literale nicht unterstützt werden.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Literale unterstützt werden:<br/>SQL_DL_SQL92_DATE<br/>SQL_DL_SQL92_TIME<br/>SQL_DL_SQL92_TIMESTAMP<br/>SQL_DL_SQL92_INTERVAL_YEAR<br/>SQL_DL_SQL92_INTERVAL_MONTH<br/>SQL_DL_SQL92_INTERVAL_DAY<br/>SQL_DL_SQL92_INTERVAL_HOUR<br/>SQL_DL_SQL92_INTERVAL_MINUTE<br/>SQL_DL_SQL92_INTERVAL_SECOND<br/>SQL_DL_SQL92_INTERVAL_YEAR_TO_MONTH<br/>SQL_DL_SQL92_INTERVAL_DAY_TO_HOUR<br/>SQL_DL_SQL92_INTERVAL_DAY_TO_MINUTE<br/>SQL_DL_SQL92_INTERVAL_DAY_TO_SECOND<br/>SQL_DL_SQL92_INTERVAL_HOUR_TO_MINUTE<br/>SQL_DL_SQL92_INTERVAL_HOUR_TO_SECOND<br/>SQL_DL_SQL92_INTERVAL_MINUTE_TO_SECOND|
|SQL_DBMS_NAME|1.0|Eine Zeichenfolge mit dem Namen des DBMS-Produkts, auf das der Treiber zugreift.|
|SQL_DBMS_VER|1.0|Eine Zeichenfolge, die die Version des DBMS-Produkts angibt, auf das der Treiber zugreift. Die Version hat das Format # #. # #. # # # #, wobei die ersten beiden Ziffern die Hauptversion sind, die nächsten zwei Ziffern die neben Version sind und die letzten vier Ziffern die Releaseversion sind. Der Treiber muss die DBMS-Produktversion in diesem Formular darstellen, kann jedoch auch die produktspezifische DBMS-Version anfügen. Beispiel: "04.01.0000 RDB 4,1".|
|SQL_DDL_INDEX|3.0|Ein SQLUINTEGER-Wert, der die Unterstützung für das Erstellen und Löschen von Indizes angibt:<br/>SQL_DI_CREATE_INDEX<br/>SQL_DI_DROP_INDEX|
|SQL_DEFAULT_TXN_ISOLATION|1.0|Ein SQLUINTEGER-Wert, der die vom Treiber oder der Datenquelle unterstützte Standard Transaktions Isolationsstufe angibt, oder 0 (null), wenn die Datenquelle keine Transaktionen unterstützt. Die folgenden Begriffe werden verwendet, um Transaktions Isolations Stufen zu definieren:<br/>**Dirty Read** Transaktion 1 ändert eine Zeile. Transaktion 2 liest die geänderte Zeile, bevor Transaktion 1 einen Commit für die Änderung ausführt. Wenn Transaktion 1 ein Rollback der Änderung ausführt, hat Transaction 2 eine Zeile gelesen, die als nie vorhanden angesehen wird.<br/>**Nicht wiederholbarer Lese** Vorgang Transaktion 1 liest eine Zeile. Transaktion 2 aktualisiert oder löscht diese Zeile und führt einen Commit für diese Änderung aus. Wenn Transaktion 1 versucht, die Zeile erneut zu lesen, empfängt Sie andere Zeilen Werte oder ermittelt, dass die Zeile gelöscht wurde.<br/>**Phantom** Transaktion 1 liest eine Reihe von Zeilen, die einige Suchkriterien erfüllen. Transaktion 2 generiert eine oder mehrere Zeilen (entweder über Einfügungen oder Updates), die den Suchkriterien entsprechen. Wenn Transaktion 1 die Anweisung, die die Zeilen liest, erneut ausführt, empfängt Sie einen anderen Satz von Zeilen.<br/><br/>Wenn die Datenquelle Transaktionen unterstützt, gibt der Treiber eine der folgenden Bitmasks zurück:<br/>SQL_TXN_READ_UNCOMMITTED = Dirty Reads, nicht wiederholbare Lesevorgänge und Phantome sind möglich.<br/>SQL_TXN_READ_COMMITTED = Dirty Reads sind nicht möglich. Nicht wiederholbare Lesevorgänge und Phantome sind möglich.<br/>SQL_TXN_REPEATABLE_READ = Dirty Reads und nicht wiederholbare Lesevorgänge sind nicht möglich. Phantome sind möglich.<br/>SQL_TXN_SERIALIZABLE = Transaktionen sind serialisierbar. Serialisierbare Transaktionen lassen keine Dirty Reads, nicht wiederholbare Lesevorgänge oder Phantome zu.|
|SQL_DESCRIBE_PARAMETER|3.0|Eine Zeichenfolge: "Y", wenn Parameter beschrieben werden können. "N", falls nicht.<br/><br/>Ein vollständig konformitäteter SQL-92-Treiber gibt normalerweise "Y" zurück, da er die **Beschreibung der Eingabe** Anweisung unterstützt. Da dies die zugrunde liegende SQL-Unterstützung nicht direkt angibt, wird das Beschreiben von Parametern möglicherweise nicht unterstützt, auch in einem vollständig kompatiblen SQL-92-Treiber.|
|SQL_DM_VER|3.0|Eine Zeichenfolge mit der Version des Treiber-Managers. Die Version hat das Format # #. # #. # # # #. # # # #, wobei:<br/>Der erste Satz von zwei Ziffern ist die Hauptversion von ODBC, wie vom Konstanten SQL_SPEC_MAJOR angegeben.<br/>Der zweite Satz von zwei Ziffern ist die kleinere ODBC-Version, die vom Konstanten SQL_SPEC_MINOR angegeben wird.<br/>Der dritte Satz von vier Ziffern ist die Hauptbuildnummer des Treiber-Managers.<br/>Der letzte Satz von vier Ziffern ist die untergeordnete Buildnummer des Treiber-Managers.<br/>Die Version des Windows 7-Treiber-Managers ist 03,80. Windows 8 Driver Manager Version ist 03,81.|
|SQL_DRIVER_AWARE_POOLING_SUPPORTED|3.8|Ein SQLUINTEGER-Wert, der angibt, ob der Treiber Treiber fähiges Pooling unterstützt. (Weitere Informationen finden Sie unter [Treiber fähiges Verbindungs Pooling](../develop-app/driver-aware-connection-pooling.md).<br/><br/>SQL_DRIVER_AWARE_POOLING_CAPABLE gibt an, dass der Treiber den Treiber fähigen Pooling-Mechanismus unterstützen kann.<br/>SQL_DRIVER_AWARE_POOLING_NOT_CAPABLE gibt an, dass der Treiber den Treiber fähigen Pooling-Mechanismus nicht unterstützen kann.<br/><br/>Ein Treiber muss SQL_DRIVER_AWARE_POOLING_SUPPORTED nicht implementieren, und der Treiber-Manager berücksichtigt nicht den Rückgabewert des Treibers.|
|SQL_DRIVER_HDBCSQL_DRIVER_HENV|1.0|Ein SQLULEN-Wert, das Umgebungs Handle oder Verbindungs Handle des Treibers, der durch das-Argument *InfoType*bestimmt wird.<br/><br/>Diese Informationstypen werden allein vom Treiber-Manager implementiert.|
|SQL_DRIVER_HDESC|3.0|Ein SQLULEN-Wert, der vom Deskriptorhandle des Treiber-Managers festgelegte Deskriptorhandle des Treibers, das von \* der Anwendung in *infovalueptr* eingegeben werden muss. In diesem Fall ist *infovalueptr* ein Eingabe-und ein Ausgabe Argument. Das an \* *infovalueptr* weiter gegebene Eingabe Deskriptorhandle muss dem *connectionHandle*entweder explizit oder implizit zugeordnet worden sein.<br/><br/>Die Anwendung sollte eine Kopie des Deskriptorhandles des Treiber-Managers erstellen, bevor **SQLGetInfo** mit diesem Informationstyp aufgerufen wird, um sicherzustellen, dass das Handle bei der Ausgabe nicht überschrieben wird.<br/><br/>Dieser Informationstyp wird nur vom Treiber-Manager implementiert.|
|SQL_DRIVER_HLIB|2.0|Ein SQLULEN-Wert, der *hInst* aus der Load-Bibliothek, der beim Laden der Treiber-DLL auf einem Microsoft Windows-Betriebssystem oder einem anderen Betriebssystem an den Treiber-Manager zurückgegeben wurde. Das Handle ist nur für das beim Aufrufen von **SQLGetInfo**angegebene Verbindungs Handle gültig.<br/><br/>Dieser Informationstyp wird nur vom Treiber-Manager implementiert.|
|SQL_DRIVER_HSTMT|1.0|Ein SQLULEN-Wert, der vom Treiber-Manager-Anweisungs Handle festgelegte Anweisungs Handle des Treibers, das von \* der Anwendung in *infovalueptr* eingegeben werden muss. In diesem Fall ist *infovalueptr* sowohl ein Eingabe-als auch ein Output-Argument. Das an \* *infovalueptr* weiter gegebene Eingabe Anweisungs Handle muss dem Argument *connectionHandle*zugeordnet worden sein.<br/><br/>Die Anwendung sollte eine Kopie des Anweisungs Handles des Treiber-Managers erstellen, bevor **SQLGetInfo** mit diesem Informationstyp aufgerufen wird, um sicherzustellen, dass das Handle bei der Ausgabe nicht überschrieben wird.<br/><br/>Dieser Informationstyp wird nur vom Treiber-Manager implementiert.|
|SQL_DRIVER_NAME|1.0|Eine Zeichenfolge mit dem Dateinamen des Treibers, der für den Zugriff auf die Datenquelle verwendet wird.|
|SQL_DRIVER_ODBC_VER|2.0|Eine Zeichenfolge mit der Version von ODBC, die der Treiber unterstützt. Die Version hat das Format # #. # #, wobei die ersten beiden Ziffern die Hauptversion und die nächsten zwei Ziffern die neben Version sind. SQL_SPEC_MAJOR und SQL_SPEC_MINOR definieren die Haupt-und neben Versionsnummern. Bei der in diesem Handbuch beschriebenen Version von ODBC sind diese 3 und 0, und der Treiber sollte "03,00" zurückgeben.<br/><br/>Der ODBC-Treiber-Manager ändert den Rückgabewert von SQLGetInfo (SQL_DRIVER_ODBC_VER) nicht, um die Abwärtskompatibilität für vorhandene Anwendungen aufrechtzuerhalten. Der Treiber gibt an, welcher Wert zurückgegeben wird. Ein Treiber, der die Erweiterbarkeit des C-Datentyps unterstützt, muss jedoch 3,8 (oder höher) zurückgeben, wenn eine Anwendung **SQLSetEnvAttr** aufruft, um SQL_ATTR_ODBC_VERSION auf 3,8 festzulegen. Weitere Informationen finden Sie unter [C-Datentypen in ODBC](../develop-app/c-data-types-in-odbc.md).|
|SQL_DRIVER_VER|1.0|Eine Zeichenfolge mit der Version des Treibers und optional eine Beschreibung des Treibers. Die Version hat mindestens das Format # #. # #. # # # #, wobei die ersten beiden Ziffern die Hauptversion sind, die nächsten zwei Ziffern die neben Version sind und die letzten vier Ziffern die Releaseversion sind.|
|SQL_DROP_ASSERTION|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Drop** Assert-Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgende Bitmaske wird verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_DA_DROP_ASSERTION<br/><br/>Bei einem vollständig kompatiblen SQL-92-Treiber wird diese Option immer als unterstützt zurückgegeben.|
|SQL_DROP_CHARACTER_SET|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Drop Character Set** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgende Bitmaske wird verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_DCS_DROP_CHARACTER_SET<br/><br/>Bei einem vollständig kompatiblen SQL-92-Treiber wird diese Option immer als unterstützt zurückgegeben.|
|SQL_DROP_COLLATION|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Drop Collation** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgende Bitmaske wird verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_DC_DROP_COLLATION<br/><br/>Bei einem vollständig kompatiblen SQL-92-Treiber wird diese Option immer als unterstützt zurückgegeben.|
|SQL_DROP_DOMAIN|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Drop Domain** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_DD_DROP_DOMAIN<br/>SQL_DD_CASCADE<br/>SQL_DD_RESTRICT<br/><br/>Ein SQL-92-Intermediate Level-konformitäter-Treiber gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_DROP_SCHEMA|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Drop Schema** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_DS_DROP_SCHEMA<br/>SQL_DS_CASCADE<br/>SQL_DS_RESTRICT<br/><br/>Ein SQL-92-Intermediate Level-konformitäter-Treiber gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_DROP_TABLE|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **DROP TABLE** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_DT_DROP_TABLE<br/>SQL_DT_CASCADE<br/>SQL_DT_RESTRICT<br/><br/>Ein mit der Anwendung für die Übergangs Ebene übergebender PPS gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_DROP_TRANSLATION|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Drop Translation** -Anweisung auflistet, wie in SQL-92 definiert, die von der Datenquelle unterstützt wird.<br/><br/>Die folgende Bitmaske wird verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_DTR_DROP_TRANSLATION<br/><br/>Bei einem vollständig kompatiblen SQL-92-Treiber wird diese Option immer als unterstützt zurückgegeben.|
|SQL_DROP_VIEW|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln in der **Drop View** -Anweisung auflistet, wie in SQL-92 definiert, von der Datenquelle unterstützt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln unterstützt werden:<br/>SQL_DV_DROP_VIEW<br/>SQL_DV_CASCADE<br/>SQL_DV_RESTRICT<br/><br/>Ein mit der Anwendung für die Übergangs Ebene übergebender PPS gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_DYNAMIC_CURSOR_ATTRIBUTES1|3.0|Eine SQLUINTEGER-Bitmaske, die die Attribute eines dynamischen Cursors beschreibt, die vom Treiber unterstützt werden. Diese Bitmaske enthält die erste Teilmenge von Attributen. die zweite Teilmenge finden Sie unter SQL_DYNAMIC_CURSOR_ATTRIBUTES2.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Attribute unterstützt werden:<br/>SQL_CA1_NEXT = ein *FetchOrientation* -Argument von SQL_FETCH_NEXT wird in einem Befehl von **SQLFetchScroll** unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_ABSOLUTE = *FetchOrientation* -Argumente von SQL_FETCH_FIRST, SQL_FETCH_LAST und SQL_FETCH_ABSOLUTE werden bei einem-Befehl von **SQLFetchScroll** unterstützt, wenn der Cursor ein dynamischer Cursor ist. (Das Rowset, das abgerufen wird, ist unabhängig von der aktuellen Cursorposition.)<br/>SQL_CA1_RELATIVE = *FetchOrientation* -Argumente von SQL_FETCH_PRIOR und SQL_FETCH_RELATIVE werden bei einem-Befehl von **SQLFetchScroll** unterstützt, wenn der Cursor ein dynamischer Cursor ist. (Das Rowset, das abgerufen wird, hängt von der aktuellen Cursorposition ab. Beachten Sie, dass dies von SQL_FETCH_NEXT getrennt ist, da in einem Vorwärts Cursor nur SQL_FETCH_NEXT unterstützt wird.)<br/>SQL_CA1_BOOKMARK = ein *FetchOrientation* -Argument von SQL_FETCH_BOOKMARK wird in einem Befehl von **SQLFetchScroll** unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_LOCK_EXCLUSIVE = ein *LockType* -Argument von SQL_LOCK_EXCLUSIVE wird in einem-Befehl von **SQLSetPos** unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_LOCK_NO_CHANGE = ein *LockType* -Argument von SQL_LOCK_NO_CHANGE wird in einem-Befehl von **SQLSetPos** unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_LOCK_UNLOCK = ein *LockType* -Argument von SQL_LOCK_UNLOCK wird in einem-Befehl von **SQLSetPos** unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_POS_POSITION = ein *Vorgangs* Argument SQL_POSITION wird in einem Aufrufen von **SQLSetPos** unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_POS_UPDATE = ein *Vorgangs* Argument SQL_UPDATE wird in einem Aufrufen von **SQLSetPos** unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_POS_DELETE = ein *Vorgangs* Argument SQL_DELETE wird in einem Aufrufen von **SQLSetPos** unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_POS_REFRESH = ein *Vorgangs* Argument SQL_REFRESH wird in einem Aufrufen von **SQLSetPos** unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_POSITIONED_UPDATE = ein Update, bei dem die Current of SQL-Anweisung unterstützt wird, wenn der Cursor ein dynamischer Cursor ist. (Ein SQL-92 Entry Level-konformitäter Treiber gibt diese Option immer als unterstützt zurück.)<br/>SQL_CA1_POSITIONED_DELETE = eine DELETE WHERE CURRENT of SQL-Anweisung wird unterstützt, wenn der Cursor ein dynamischer Cursor ist. (Ein SQL-92 Entry Level-konformitäter Treiber gibt diese Option immer als unterstützt zurück.)<br/>SQL_CA1_SELECT_FOR_UPDATE = eine SELECT for Update-SQL-Anweisung wird unterstützt, wenn der Cursor ein dynamischer Cursor ist. (Ein SQL-92 Entry Level-konformitäter Treiber gibt diese Option immer als unterstützt zurück.)<br/>SQL_CA1_BULK_ADD = ein *Vorgangs* Argument SQL_ADD wird in einem **SQLBulkOperations** -Befehl unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_BULK_UPDATE_BY_BOOKMARK = ein *Vorgangs* Argument SQL_UPDATE_BY_BOOKMARK wird in einem **SQLBulkOperations** -Befehl unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_BULK_DELETE_BY_BOOKMARK = ein *Vorgangs* Argument SQL_DELETE_BY_BOOKMARK wird in einem **SQLBulkOperations** -Befehl unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA1_BULK_FETCH_BY_BOOKMARK = ein *Vorgangs* Argument SQL_FETCH_BY_BOOKMARK wird in einem **SQLBulkOperations** -Befehl unterstützt, wenn der Cursor ein dynamischer Cursor ist.<br/><br/>Ein mit SQL-92 zwischenebenenkonformen Treiber gibt in der Regel die Optionen SQL_CA1_NEXT, SQL_CA1_ABSOLUTE und SQL_CA1_RELATIVE als unterstützt zurück, da er scrollbare Cursor durch die eingebettete SQL-FETCH-Anweisung unterstützt. Da dadurch die zugrunde liegende SQL-Unterstützung nicht direkt bestimmt wird, werden scrollfähige Cursor möglicherweise nicht unterstützt, auch für einen zwischengeschalteten SQL-92-untergeordneten Treiber.|
|SQL_DYNAMIC_CURSOR_ATTRIBUTES2|3.0|Eine SQLUINTEGER-Bitmaske, die die Attribute eines dynamischen Cursors beschreibt, die vom Treiber unterstützt werden. Diese Bitmaske enthält die zweite Teilmenge von Attributen. die erste Teilmenge finden Sie unter SQL_DYNAMIC_CURSOR_ATTRIBUTES1.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Attribute unterstützt werden:<br/>SQL_CA2_READ_ONLY_CONCURRENCY = ein Schreib geschützter dynamischer Cursor, bei dem keine Updates zulässig sind, wird unterstützt. (Das SQL_ATTR_CONCURRENCY Statement-Attribut kann für einen dynamischen Cursor SQL_CONCUR_READ_ONLY werden).<br/>SQL_CA2_LOCK_CONCURRENCY = ein dynamischer Cursor, der die niedrigste Sperr Ebene verwendet, um sicherzustellen, dass die Zeile aktualisiert werden kann, wird unterstützt. (Das SQL_ATTR_CONCURRENCY Statement-Attribut kann für einen dynamischen Cursor SQL_CONCUR_LOCK werden.) Diese Sperren müssen mit der Transaktions Isolationsstufe übereinstimmen, die vom SQL_ATTR_TXN_ISOLATION-Verbindungs Attribut festgelegt wird.<br/>SQL_CA2_OPT_ROWVER_CONCURRENCY = ein dynamischer Cursor, der das Steuerelement für die vollständige Parallelität verwendet, bei dem die Zeilen Versionen verglichen werden (Das SQL_ATTR_CONCURRENCY Statement-Attribut kann für einen dynamischen Cursor SQL_CONCUR_ROWVER werden.)<br/>SQL_CA2_OPT_VALUES_CONCURRENCY = ein dynamischer Cursor, der den Vergleich von Werten mit optimistischer Parallelität verwendet, wird unterstützt. (Das SQL_ATTR_CONCURRENCY Statement-Attribut kann für einen dynamischen Cursor SQL_CONCUR_VALUES werden.)<br/>SQL_CA2_SENSITIVITY_ADDITIONS = hinzugefügte Zeilen sind für einen dynamischen Cursor sichtbar. der Cursor kann einen Bildlauf zu diesen Zeilen durchführen. (Wobei diese Zeilen dem Cursor hinzugefügt werden, ist Treiber abhängig.)<br/>SQL_CA2_SENSITIVITY_DELETIONS = gelöschte Zeilen sind nicht mehr für einen dynamischen Cursor verfügbar und lassen kein "Loch" im Resultset aus. Nachdem der dynamische Cursor einen Bildlauf aus einer gelöschten Zeile durchgeführt hat, kann er nicht zu dieser Zeile zurückkehren<br/>SQL_CA2_SENSITIVITY_UPDATES = Aktualisierungen von Zeilen sind für einen dynamischen Cursor sichtbar. Wenn der dynamische Cursor einen Bildlauf durchführt und zu einer aktualisierten Zeile zurückkehrt, sind die vom Cursor zurückgegebenen Daten die aktualisierten Daten, nicht die ursprünglichen Daten.<br/>SQL_CA2_MAX_ROWS_SELECT = das Attribut der SQL_ATTR_MAX_ROWS Anweisung wirkt sich auf **Select** -Anweisungen aus, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA2_MAX_ROWS_INSERT = das Attribut der SQL_ATTR_MAX_ROWS Anweisung wirkt sich auf **Insert** -Anweisungen aus, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA2_MAX_ROWS_DELETE = das Attribut der SQL_ATTR_MAX_ROWS Anweisung wirkt sich auf **Delete** -Anweisungen aus, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA2_MAX_ROWS_UPDATE = das Attribut der SQL_ATTR_MAX_ROWS Anweisung wirkt sich auf **Update** -Anweisungen aus, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA2_MAX_ROWS_CATALOG = das Attribut der SQL_ATTR_MAX_ROWS Anweisung wirkt sich auf die **Katalog** Resultsets aus, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA2_MAX_ROWS_AFFECTS_ALL = das Attribut der SQL_ATTR_MAX_ROWS Anweisung wirkt sich auf **Select**-, **Insert**-, **Delete**-und **Update** -Anweisungen sowie auf **Katalog** Resultsets aus, wenn der Cursor ein dynamischer Cursor ist.<br/>SQL_CA2_CRC_EXACT = die genaue Zeilen Anzahl ist im SQL_DIAG_CURSOR_ROW_COUNT Diagnose Feld verfügbar, wenn es sich um einen dynamischen Cursor handelt.<br/>SQL_CA2_CRC_APPROXIMATE = eine ungefähre Zeilen Anzahl ist im SQL_DIAG_CURSOR_ROW_COUNT Diagnose Feld verfügbar, wenn es sich um einen dynamischen Cursor handelt.<br/>SQL_CA2_SIMULATE_NON_UNIQUE = der Treiber garantiert nicht, dass simulierte positionierte UPDATE-oder DELETE-Anweisungen nur eine Zeile betreffen, wenn der Cursor ein dynamischer Cursor ist. Es liegt in der Verantwortung der Anwendung, dies zu gewährleisten. (Wenn eine-Anweisung mehr als eine Zeile betrifft, gibt **SQLExecute** oder **SQLExecDirect** SQLSTATE 01001 [Cursor Vorgangs Konflikt] zurück.) Um dieses Verhalten festzulegen, ruft die Anwendung **SQLSetStmtAttr** auf, wobei das SQL_ATTR_SIMULATE_CURSOR-Attribut auf SQL_SC_NON_UNIQUE festgelegt ist.<br/>SQL_CA2_SIMULATE_TRY_UNIQUE = der Treiber versucht sicherzustellen, dass sich simulierte positionierte UPDATE-oder DELETE-Anweisungen nur auf eine Zeile auswirken, wenn der Cursor ein dynamischer Cursor ist. Der Treiber führt diese Anweisungen immer aus, auch wenn Sie sich auf mehr als eine Zeile auswirken können, z. b. Wenn kein eindeutiger Schlüssel vorhanden ist. (Wenn eine-Anweisung mehr als eine Zeile betrifft, gibt **SQLExecute** oder **SQLExecDirect** SQLSTATE 01001 [Cursor Vorgangs Konflikt] zurück.) Um dieses Verhalten festzulegen, ruft die Anwendung **SQLSetStmtAttr** auf, wobei das SQL_ATTR_SIMULATE_CURSOR-Attribut auf SQL_SC_TRY_UNIQUE festgelegt ist.<br/>SQL_CA2_SIMULATE_UNIQUE = der Treiber gewährleistet, dass sich simulierte positionierte UPDATE-oder DELETE-Anweisungen nur auf eine Zeile auswirken, wenn der Cursor ein dynamischer Cursor ist. Wenn der Treiber dies für eine bestimmte Anweisung nicht garantieren kann, geben **SQLExecDirect** oder **SQLPrepare** SQLSTATE 01001 (Cursor Vorgangs Konflikt) zurück. Um dieses Verhalten festzulegen, ruft die Anwendung **SQLSetStmtAttr** auf, wobei das SQL_ATTR_SIMULATE_CURSOR-Attribut auf SQL_SC_UNIQUE festgelegt ist.|
|SQL_EXPRESSIONS_IN_ORDERBY|1.0|Eine Zeichenfolge: "Y", wenn die Datenquelle Ausdrücke in der **Order by** -Liste unterstützt. "N", wenn dies nicht der Fall ist.|
|SQL_FILE_USAGE|2.0|Ein sqlusmallint-Wert, der angibt, wie ein Single-Tier-Treiberdateien in einer Datenquelle direkt behandelt:<br/>SQL_FILE_NOT_SUPPORTED = der Treiber ist kein Single-Tier-Treiber. Ein Oracle-Treiber ist beispielsweise ein Treiber mit zwei Ebenen.<br/>SQL_FILE_TABLE = ein Single-Tier-Treiber behandelt Dateien in einer Datenquelle als Tabellen. Ein xbase-Treiber behandelt z. b. die einzelnen xbase-Dateien als Tabelle.<br/>SQL_FILE_CATALOG = ein Single-Tier-Treiber behandelt Dateien in einer Datenquelle als Katalog. Beispielsweise behandelt ein Microsoft Access-Treiber jede Microsoft Access-Datei als eine komplette Datenbank.<br/><br/>Diese kann von einer Anwendung verwendet werden, um zu bestimmen, wie Benutzerdaten auswählen. Xbase-Benutzer betrachten beispielsweise häufig Daten, die in Dateien gespeichert sind, während Oracle-und Microsoft Access-Benutzer in der Regel Daten als in Tabellen gespeicherten Daten betrachten.<br/><br/>Wenn ein Benutzer eine xbase-Datenquelle auswählt, kann die Anwendung das Dialogfeld "Windows- **Datei öffnen** (allgemein)" anzeigen. Wenn der Benutzer eine Microsoft Access-oder Oracle-Datenquelle auswählt, kann die Anwendung ein benutzerdefiniertes Dialogfeld **Tabelle auswählen** anzeigen.|
|SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1|3.0|Eine SQLUINTEGER-Bitmaske, die die Attribute eines vorwärts Cursors beschreibt, die vom Treiber unterstützt werden. Diese Bitmaske enthält die erste Teilmenge von Attributen. die zweite Teilmenge finden Sie unter SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Attribute unterstützt werden:<br/>SQL_CA1_NEXT<br/>SQL_CA1_LOCK_EXCLUSIVE<br/>SQL_CA1_LOCK_NO_CHANGE<br/>SQL_CA1_LOCK_UNLOCK<br/>SQL_CA1_POS_POSITION<br/>SQL_CA1_POS_UPDATE<br/>SQL_CA1_POS_DELETE<br/>SQL_CA1_POS_REFRESH<br/>SQL_CA1_POSITIONED_UPDATE<br/>SQL_CA1_POSITIONED_DELETE<br/>SQL_CA1_SELECT_FOR_UPDATE<br/>SQL_CA1_BULK_ADD<br/>SQL_CA1_BULK_UPDATE_BY_BOOKMARK<br/>SQL_CA1_BULK_DELETE_BY_BOOKMARK<br/>SQL_CA1_BULK_FETCH_BY_BOOKMARK<br/><br/>Beschreibungen dieser Bitmasks finden Sie unter SQL_DYNAMIC_CURSOR_ATTRIBUTES1 (und Ersetzen des vorwärts Cursors für "Dynamic Cursor" in den Beschreibungen).|
|SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2|3.0|Eine SQLUINTEGER-Bitmaske, die die Attribute eines vorwärts Cursors beschreibt, die vom Treiber unterstützt werden. Diese Bitmaske enthält die zweite Teilmenge von Attributen. die erste Teilmenge finden Sie unter SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Attribute unterstützt werden:<br/>SQL_CA2_READ_ONLY_CONCURRENCY<br/>SQL_CA2_LOCK_CONCURRENCY<br/>SQL_CA2_OPT_ROWVER_CONCURRENCY<br/>SQL_CA2_OPT_VALUES_CONCURRENCY<br/>SQL_CA2_SENSITIVITY_ADDITIONS<br/>SQL_CA2_SENSITIVITY_DELETIONS<br/>SQL_CA2_SENSITIVITY_UPDATES<br/>SQL_CA2_MAX_ROWS_SELECT<br/>SQL_CA2_MAX_ROWS_INSERT<br/>SQL_CA2_MAX_ROWS_DELETE<br/>SQL_CA2_MAX_ROWS_UPDATE<br/>SQL_CA2_MAX_ROWS_CATALOG<br/>SQL_CA2_MAX_ROWS_AFFECTS_ALL<br/>SQL_CA2_CRC_EXACT<br/>SQL_CA2_CRC_APPROXIMATE<br/>SQL_CA2_SIMULATE_NON_UNIQUE<br/>SQL_CA2_SIMULATE_TRY_UNIQUE<br/>SQL_CA2_SIMULATE_UNIQUE<br/><br/>Beschreibungen dieser Bitmasks finden Sie unter SQL_DYNAMIC_CURSOR_ATTRIBUTES2 (und Ersetzen des vorwärts Cursors für "Dynamic Cursor" in den Beschreibungen).|
|SQL_GETDATA_EXTENSIONS|2.0|Eine SQLUINTEGER-Bitmaske, die Erweiterungen für **SQLGetData**auflistet.<br/><br/>Die folgenden Bitmasken werden gemeinsam mit dem-Flag verwendet, um zu bestimmen, welche allgemeinen Erweiterungen der Treiber für **SQLGetData**unterstützt:<br/>SQL_GD_ANY_COLUMN = **SQLGetData** kann für jede nicht gebundene Spalte aufgerufen werden, einschließlich derjenigen vor der letzten gebundenen Spalte. Beachten Sie, dass die Spalten in Reihenfolge der aufsteigenden Spaltennummer aufgerufen werden müssen, es sei denn, SQL_GD_ANY_ORDER ebenfalls zurückgegeben wird<br/>SQL_GD_ANY_ORDER = **SQLGetData** kann für ungebundene Spalten in beliebiger Reihenfolge aufgerufen werden. Beachten Sie, dass **SQLGetData** nur für Spalten nach der letzten gebundenen Spalte aufgerufen werden kann, es sei denn, SQL_GD_ANY_COLUMN wird ebenfalls zurückgegeben.<br/>SQL_GD_BLOCK = **SQLGetData** kann für eine ungebundene Spalte in einer Zeile in einem-Block (in der die Rowsetgröße größer als 1 ist) von Daten nach der Positionierung in dieser Zeile mit **SQLSetPos**aufgerufen werden.<br/>SQL_GD_BOUND = **SQLGetData** kann nicht nur für ungebundene Spalten, sondern auch für gebundene Spalten aufgerufen werden. Ein Treiber kann diesen Wert nur zurückgeben, wenn er auch SQL_GD_ANY_COLUMN zurückgibt.<br/>SQL_GD_OUTPUT_PARAMS = **SQLGetData** kann aufgerufen werden, um Ausgabeparameter Werte zurückzugeben. Weitere Informationen finden Sie unter [Abrufen von Ausgabeparametern mit SQLGetData](../develop-app/retrieving-output-parameters-using-sqlgetdata.md).<br/><br/>**SQLGetData** ist erforderlich, um nur Daten aus ungebundenen Spalten zurückzugeben, die nach der letzten gebundenen Spalte auftreten, in der Reihenfolge der zunehmenden Spaltennummer aufgerufen werden und sich nicht in einer Zeile in einem Zeilen Block befinden.<br/><br/>Wenn ein Treiber Lesezeichen (mit fester oder variabler Länge) unterstützt, muss er das Aufrufen von **SQLGetData** für Spalte 0 unterstützen. Diese Unterstützung ist unabhängig davon erforderlich, was der Treiber für einen **SQLGetInfo-Befehl** mit dem SQL_GETDATA_EXTENSIONS *InfoType*zurückgibt.|
|SQL_GROUP_BY|2.0|Ein sqlusmallint-Wert, der die Beziehung zwischen den Spalten in der **Group by** -Klausel und den nicht aggregierten Spalten in der SELECT-Liste angibt:<br/>SQL_GB_COLLATE = eine **COLLATE** -Klausel kann am Ende jeder Gruppierungs Spalte angegeben werden. (ODBC 3,0)<br/>SQL_GB_NOT_SUPPORTED = **Group by** -Klauseln werden nicht unterstützt. (ODBC 2,0)<br/>SQL_GB_GROUP_BY_EQUALS_SELECT = die **Group by** -Klausel muss alle nicht aggregierten Spalten in der SELECT-Liste enthalten. Er darf keine anderen Spalten enthalten. Wählen Sie z. b. die Option "out" **, "Max (Gehalt)" von Employee Group by de aus**. (ODBC 2,0)<br/>SQL_GB_GROUP_BY_CONTAINS_SELECT = die **Group by** -Klausel muss alle nicht aggregierten Spalten in der SELECT-Liste enthalten. Sie kann Spalten enthalten, die nicht in der SELECT-Liste enthalten sind. Wählen Sie z. b. die Option " **de", "Max (Gehalt)" aus Employee Group by de, Age aus**. (ODBC 2,0)<br/>SQL_GB_NO_RELATION = die Spalten in der **Group by** -Klausel und die SELECT-Liste sind nicht verknüpft. Die Bedeutung von nicht gruppierten, nicht aggregierten Spalten in der SELECT-Liste ist Datenquellen abhängig. Wählen Sie z. b. die Option " **de", "Gehalt von Employee Group by de", "Age**" (ODBC 2,0)<br/><br/>Ein in SQL-92 Eintrags Level übergebender Treiber gibt die SQL_GB_GROUP_BY_EQUALS_SELECT Option immer wie unterstützt zurück. Ein vollständig konformen SQL-92-Treiber gibt die SQL_GB_COLLATE-Option immer wie unterstützt zurück. Wenn keine der Optionen unterstützt wird, wird die **Group by** -Klausel von der Datenquelle nicht unterstützt.|
|SQL_IDENTIFIER_CASE|1.0|Einen sqlusmallint-Wert wie folgt:<br/>Bei SQL_IC_UPPER =-Bezeichner in SQL wird die Groß-/Kleinschreibung nicht beachtet, und Sie werden in Großbuchstaben im System Katalog gespeichert.<br/>Bei SQL_IC_LOWER =-Bezeichner in SQL wird die Groß-/Kleinschreibung nicht beachtet und in Kleinbuchstaben im System Katalog gespeichert.<br/>Bei SQL_IC_SENSITIVE = Bezeichner in SQL wird die Groß-/Kleinschreibung beachtet und in einem gemischten Fall im System Katalog gespeichert.<br/>Bei SQL_IC_MIXED = Bezeichner in SQL wird die Groß-/Kleinschreibung nicht beachtet, und Sie werden in einem gemischten Fall im System Katalog gespeichert.<br/><br/>Da bei bezeichgern in SQL-92 die Groß-/Kleinschreibung nicht beachtet wird, gibt ein Treiber, der genau SQL-92 (Any Level) entspricht, niemals die SQL_IC_SENSITIVE-Option wie unterstützt zurück.|
|SQL_IDENTIFIER_QUOTE_CHAR|1.0|Die Zeichenfolge, die als Anfangs-und endtrennzeichen eines Bezeichners in Anführungszeichen (getrennt) in SQL-Anweisungen verwendet wird. (Bezeichner, die als Argumente an ODBC-Funktionen übermittelt wurden, müssen nicht in Anführungszeichen gesetzt werden.) Wenn die Datenquelle keine Bezeichner in Anführungszeichen unterstützt, wird eine leere zurückgegeben.<br/><br/>Diese Zeichenfolge kann auch zum Zitieren von Katalog Funktions Argumenten verwendet werden, wenn das Verbindungs Attribut SQL_ATTR_METADATA_ID auf SQL_TRUE festgelegt ist.<br/><br/>Da es sich bei dem bezeichneranführungs Zeichen in SQL-92 um das doppelte Anführungszeichen (") handelt, gibt ein Treiber, der genau SQL-92 entspricht, immer das doppelte Anführungszeichen zurück.|
|SQL_INDEX_KEYWORDS|3.0|Eine SQLUINTEGER-Bitmaske, die Schlüsselwörter in der CREATE INDEX-Anweisung auflistet, die vom Treiber unterstützt werden:<br/>SQL_IK_NONE = keines der Schlüsselwörter wird unterstützt.<br/>SQL_IK_ASC = ASC-Schlüsselwort wird unterstützt.<br/>SQL_IK_DESC = DESC-Schlüsselwort wird unterstützt.<br/>SQL_IK_ALL = Alle Schlüsselwörter werden unterstützt.<br/><br/>Um festzustellen, ob die CREATE INDEX-Anweisung unterstützt wird, ruft eine Anwendung **SQLGetInfo** mit dem SQL_DLL_INDEX Informationstyp auf.|
|SQL_INFO_SCHEMA_VIEWS|3.0|Eine SQLUINTEGER-Bitmaske, die die Sichten in den INFORMATION_SCHEMA auflistet, die vom Treiber unterstützt werden. Die Sichten in und der Inhalt von INFORMATION_SCHEMA sind wie in SQL-92 definiert.<br/><br/>Die SQL-92-oder FPS-Konformitätsstufe, bei der diese Funktion unterstützt werden muss, wird in Klammern neben den einzelnen Bitmasken angezeigt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Sichten unterstützt werden:<br/>SQL_ISV_ASSERTIONS = identifiziert die Assertionen des Katalogs, die sich im Besitz eines bestimmten Benutzers befinden. (Vollständig)<br/>SQL_ISV_CHARACTER_SETS = identifiziert die Zeichensätze des Katalogs, auf die ein bestimmter Benutzer zugreifen kann. (Zwischenebene)<br/>SQL_ISV_CHECK_CONSTRAINTS = identifiziert die Check-Einschränkungen, die sich im Besitz eines bestimmten Benutzers befinden. (Zwischenebene)<br/>SQL_ISV_COLLATIONS = identifiziert die Zeichen Sortierungen für den Katalog, auf die ein bestimmter Benutzer zugreifen kann. (Vollständig)<br/>SQL_ISV_COLUMN_DOMAIN_USAGE = identifiziert die Spalten für den Katalog, die von den im Katalog definierten Domänen abhängen und im Besitz eines bestimmten Benutzers sind. (Zwischenebene)<br/>SQL_ISV_COLUMN_PRIVILEGES = identifiziert die Berechtigungen für Spalten von permanenten Tabellen, die für einen bestimmten Benutzer verfügbar sind oder von diesem erteilt wurden. (Übergangs Ebene für den PPS)<br/>SQL_ISV_COLUMNS = identifiziert die Spalten von permanenten Tabellen, auf die ein bestimmter Benutzer zugreifen kann. (Übergangs Ebene für den PPS)<br/>SQL_ISV_CONSTRAINT_COLUMN_USAGE = ähnlich wie Constraint_Table_Usage Sicht werden Spalten für die verschiedenen Einschränkungen identifiziert, die einem bestimmten Benutzer gehören. (Zwischenebene)<br/>SQL_ISV_CONSTRAINT_TABLE_USAGE = identifiziert die Tabellen, die von Einschränkungen (referenziell, eindeutig und Assertionen) verwendet werden und im Besitz eines bestimmten Benutzers sind. (Zwischenebene)<br/>SQL_ISV_DOMAIN_CONSTRAINTS = identifiziert die Domänen Einschränkungen (der Domänen im Katalog), auf die ein bestimmter Benutzer zugreifen kann. (Zwischenebene)<br/>SQL_ISV_DOMAINS = identifiziert die Domänen, die in einem Katalog definiert sind und auf die der Benutzer zugreifen kann. (Zwischenebene)<br/>SQL_ISV_KEY_COLUMN_USAGE = identifiziert die im Katalog definierten Spalten, die von einem bestimmten Benutzer als Schlüssel eingeschränkt werden. (Zwischenebene)<br/>SQL_ISV_REFERENTIAL_CONSTRAINTS = identifiziert die referenziellen Einschränkungen, die sich im Besitz eines bestimmten Benutzers befinden. (Zwischenebene)<br/>SQL_ISV_SCHEMATA = identifiziert die Schemas, die sich im Besitz eines bestimmten Benutzers befinden. (Zwischenebene)<br/>SQL_ISV_SQL_LANGUAGES = identifiziert die von der SQL-Implementierung unterstützten SQL-Konformitäts Ebenen, Optionen und Dialekte. (Zwischenebene)<br/>SQL_ISV_TABLE_CONSTRAINTS = identifiziert die Tabellen Einschränkungen, die sich im Besitz eines bestimmten Benutzers befinden. (Zwischenebene)<br/>SQL_ISV_TABLE_PRIVILEGES = identifiziert die Berechtigungen für persistente Tabellen, die für einen bestimmten Benutzer verfügbar sind oder von diesem erteilt wurden. (Übergangs Ebene für den PPS)<br/>SQL_ISV_TABLES = identifiziert die permanenten Tabellen, die in einem Katalog definiert sind und auf die ein bestimmter Benutzer zugreifen kann. (Übergangs Ebene für den PPS)<br/>SQL_ISV_TRANSLATIONS = identifiziert Zeichen Übersetzungen für den Katalog, auf die ein bestimmter Benutzer zugreifen kann. (Vollständig)<br/>SQL_ISV_USAGE_PRIVILEGES = identifiziert die Nutzungs Berechtigungen für Katalog Objekte, die für einen bestimmten Benutzer verfügbar sind oder dessen Besitzer Sie sind. (Übergangs Ebene für den PPS)<br/>SQL_ISV_VIEW_COLUMN_USAGE = identifiziert die Spalten, für die die Katalog Sichten, deren Besitzer ein angegebener Benutzer ist, abhängig sind. (Zwischenebene)<br/>SQL_ISV_VIEW_TABLE_USAGE = identifiziert die Tabellen, auf die sich die Katalog Sichten im Besitz eines bestimmten Benutzers von richten. (Zwischenebene)<br/>SQL_ISV_VIEWS = identifiziert die in diesem Katalog definierten angezeigten Tabellen, auf die ein bestimmter Benutzer zugreifen kann. (Übergangs Ebene für den PPS)|
|SQL_INSERT_STATEMENT|3.0|Eine SQLUINTEGER-Bitmaske, die die Unterstützung für **Insert** -Anweisungen angibt:<br/>SQL_IS_INSERT_LITERALS<br/>SQL_IS_INSERT_SEARCHED<br/>SQL_IS_SELECT_INTO<br/><br/>Ein mit SQL-92 Eintrags Level übergebender Treiber gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_INTEGRITY|1.0|Eine Zeichenfolge: "Y", wenn die Datenquelle die Integritäts Erweiterungs Funktion unterstützt. "N", wenn dies nicht der Fall ist.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_ODBC_SQL_OPT_IEF ODBC 2,0 umbenannt.|
|SQL_KEYSET_CURSOR_ATTRIBUTES1|3.0|Eine SQLUINTEGER-Bitmaske, die die Attribute eines Keysetcursors beschreibt, die vom Treiber unterstützt werden. Diese Bitmaske enthält die erste Teilmenge von Attributen. die zweite Teilmenge finden Sie unter SQL_KEYSET_CURSOR_ATTRIBUTES2.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Attribute unterstützt werden:<br/>SQL_CA1_NEXT<br/>SQL_CA1_ABSOLUTE<br/>SQL_CA1_RELATIVE<br/>SQL_CA1_BOOKMARK<br/>SQL_CA1_LOCK_EXCLUSIVE<br/>SQL_CA1_LOCK_NO_CHANGE<br/>SQL_CA1_LOCK_UNLOCK<br/>SQL_CA1_POS_POSITION<br/>SQL_CA1_POS_UPDATE<br/>SQL_CA1_POS_DELETE<br/>SQL_CA1_POS_REFRESH<br/>SQL_CA1_POSITIONED_UPDATE<br/>SQL_CA1_POSITIONED_DELETE<br/>SQL_CA1_SELECT_FOR_UPDATE<br/>SQL_CA1_BULK_ADD<br/>SQL_CA1_BULK_UPDATE_BY_BOOKMARK<br/>SQL_CA1_BULK_DELETE_BY_BOOKMARK<br/>SQL_CA1_BULK_FETCH_BY_BOOKMARK<br/><br/>Beschreibungen dieser Bitmasks finden Sie unter SQL_DYNAMIC_CURSOR_ATTRIBUTES1 (und Ersetzen des keysetgesteuerten Cursors für "dynamischer Cursor" in den Beschreibungen).<br/><br/>Ein SQL-92-zwischen Ebenen-konformen Treiber gibt in der Regel die Optionen SQL_CA1_NEXT, SQL_CA1_ABSOLUTE und SQL_CA1_RELATIVE zurück, die unterstützt werden, da der Treiber scrollbare Cursor durch die eingebettete SQL FETCH-Anweisung unterstützt. Da dadurch die zugrunde liegende SQL-Unterstützung nicht direkt bestimmt wird, werden scrollfähige Cursor möglicherweise nicht unterstützt, auch für einen zwischengeschalteten SQL-92-untergeordneten Treiber.|
|SQL_KEYSET_CURSOR_ATTRIBUTES2|3.0|Eine SQLUINTEGER-Bitmaske, die die Attribute eines Keysetcursors beschreibt, die vom Treiber unterstützt werden. Diese Bitmaske enthält die zweite Teilmenge von Attributen. die erste Teilmenge finden Sie unter SQL_KEYSET_CURSOR_ATTRIBUTES1.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Attribute unterstützt werden:<br/>SQL_CA2_READ_ONLY_CONCURRENCY<br/>SQL_CA2_LOCK_CONCURRENCY<br/>SQL_CA2_OPT_ROWVER_CONCURRENCY<br/>SQL_CA2_OPT_VALUES_CONCURRENCY<br/>SQL_CA2_SENSITIVITY_ADDITIONS<br/>SQL_CA2_SENSITIVITY_DELETIONS<br/>SQL_CA2_SENSITIVITY_UPDATES<br/>SQL_CA2_MAX_ROWS_SELECT<br/>SQL_CA2_MAX_ROWS_INSERT<br/>SQL_CA2_MAX_ROWS_DELETE<br/>SQL_CA2_MAX_ROWS_UPDATE<br/>SQL_CA2_MAX_ROWS_CATALOG<br/>SQL_CA2_MAX_ROWS_AFFECTS_ALL<br/>SQL_CA2_CRC_EXACT<br/>SQL_CA2_CRC_APPROXIMATE<br/>SQL_CA2_SIMULATE_NON_UNIQUE<br/>SQL_CA2_SIMULATE_TRY_UNIQUE<br/>SQL_CA2_SIMULATE_UNIQUE<br/><br/>Beschreibungen dieser Bitmasks finden Sie unter SQL_DYNAMIC_CURSOR_ATTRIBUTES1 (und Ersetzen des keysetgesteuerten Cursors für "dynamischer Cursor" in den Beschreibungen).|
|SQL_KEYWORDS|2.0|Eine Zeichenfolge, die eine durch Trennzeichen getrennte Liste aller Datenquellen spezifischen Schlüsselwörter enthält. Diese Liste enthält keine Schlüsselwörter speziell für ODBC oder Schlüsselwörter, die von der Datenquelle und von ODBC verwendet werden. Diese Liste stellt alle reservierten Schlüsselwörter dar. interoperable Anwendungen sollten diese Wörter nicht in Objektnamen verwenden.<br/><br/>Eine Liste der ODBC-Schlüsselwörter finden Sie unter [reservierte Schlüsselwörter](../appendixes/reserved-keywords.md) in [Anhang C: SQL-Grammatik](../appendixes/appendix-c-sql-grammar.md). Der **#define** Wert SQL_ODBC_KEYWORDS enthält eine durch Trennzeichen getrennte Liste von ODBC-Schlüsselwörtern.|
|SQL_LIKE_ESCAPE_CLAUSE|2.0|Eine Zeichenfolge: "Y", wenn die Datenquelle ein Escapezeichen für das Prozentzeichen (%) unterstützt. und Unterstrich Zeichen (_) in einem **like** -Prädikat, und der Treiber unterstützt die ODBC-Syntax zum Definieren eines **like** -Prädikat-Escapezeichens. Andernfalls "N".|
|SQL_MAX_ASYNC_CONCURRENT_STATEMENTS|3.0|Ein SQLUINTEGER-Wert, der die maximale Anzahl aktiver gleichzeitiger Anweisungen im asynchronen Modus angibt, die der Treiber für eine bestimmte Verbindung unterstützen kann. Wenn kein bestimmtes Limit vorliegt oder der Grenzwert unbekannt ist, ist dieser Wert 0 (null).|
|SQL_MAX_BINARY_LITERAL_LEN|2.0|Ein SQLUINTEGER-Wert, der die maximale Länge (Anzahl von hexadezimalen Zeichen, ausgenommen das literalpräfix und das von **sqlgettypinfo**zurückgegebene Suffix) eines binären Literals in einer SQL-Anweisung angibt. Beispielsweise hat das binäre Literale 0xffaa eine Länge von 4. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.|
|SQL_MAX_CATALOG_NAME_LEN|1.0|Ein sqlusmallint-Wert, der die maximale Länge eines Katalog namens in der Datenquelle angibt. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.<br/><br/>Ein vollständig konformen conps-Treiber gibt mindestens 128 zurück.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_MAX_QUALIFIER_NAME_LEN ODBC 2,0 umbenannt.|
|SQL_MAX_CHAR_LITERAL_LEN|2.0|Ein SQLUINTEGER-Wert, der die maximale Länge (Anzahl der Zeichen, ausgenommen das literalpräfix und das von **sqlgettypinfo**zurückgegebene Suffix) eines Zeichenliterals in einer SQL-Anweisung angibt. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.|
|SQL_MAX_COLUMN_NAME_LEN|1.0|Ein sqlusmallint-Wert, der die maximale Länge eines Spaltennamens in der Datenquelle angibt. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 18 zurück. Ein mit der conps-Konformität zwischen Ebenen-konformen Treiber gibt mindestens 128 zurück.|
|SQL_MAX_COLUMNS_IN_GROUP_BY|2.0|Ein sqlusmallint-Wert, der die maximale Anzahl von Spalten angibt, die in einer **Group by** -Klausel zulässig sind. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 6 zurück. Ein mit dem conps-konformen und-konformen Treiber gibt mindestens 15 zurück.|
|SQL_MAX_COLUMNS_IN_INDEX|2.0|Ein sqlusmallint-Wert, der die maximale Anzahl von Spalten angibt, die in einem Index zulässig sind. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.|
|SQL_MAX_COLUMNS_IN_ORDER_BY|2.0|Ein sqlusmallint-Wert, der die maximale Anzahl von Spalten angibt, die in einer **Order by** -Klausel zulässig sind. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 6 zurück. Ein mit dem conps-konformen und-konformen Treiber gibt mindestens 15 zurück.|
|SQL_MAX_COLUMNS_IN_SELECT|2.0|Ein sqlusmallint-Wert, der die maximale Anzahl von Spalten angibt, die in einer SELECT-Liste zulässig sind. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 100 zurück. Ein mit der conps-Konformität zwischen Ebenen-konformen Treiber gibt mindestens 250 zurück.|
|SQL_MAX_COLUMNS_IN_TABLE|2.0|Ein sqlusmallint-Wert, der die maximale Anzahl von Spalten angibt, die in einer Tabelle zulässig sind. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 100 zurück. Ein mit der conps-Konformität zwischen Ebenen-konformen Treiber gibt mindestens 250 zurück.|
|SQL_MAX_CONCURRENT_ACTIVITIES|1.0|Ein sqlusmallint-Wert, der die maximale Anzahl aktiver Anweisungen angibt, die der Treiber für eine Verbindung unterstützen kann. Eine-Anweisung wird als aktiv definiert, wenn Ergebnisse ausstehen. der Begriff "Ergebnisse" bedeutet, dass Zeilen aus einem **Select** -Vorgang oder Zeilen, die von einem **Insert**-, **Update**-oder **Delete** -Vorgang betroffen sind (z. b. eine Zeilen Anzahl), oder wenn Sie sich in einem NEED_DATA Zustand befindet. Dieser Wert kann eine Einschränkung widerspiegeln, die vom Treiber oder der Datenquelle festgelegt wird. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_ACTIVE_STATEMENTS ODBC 2,0 umbenannt.|
|SQL_MAX_CURSOR_NAME_LEN|1.0|Ein sqlusmallint-Wert, der die maximale Länge eines Cursor namens in der Datenquelle angibt. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 18 zurück. Ein mit der conps-Konformität zwischen Ebenen-konformen Treiber gibt mindestens 128 zurück.|
|SQL_MAX_DRIVER_CONNECTIONS|1.0|Ein sqlusmallint-Wert, der die maximale Anzahl aktiver Verbindungen angibt, die der Treiber für eine Umgebung unterstützen kann. Dieser Wert kann eine Einschränkung widerspiegeln, die vom Treiber oder der Datenquelle festgelegt wird. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_ACTIVE_CONNECTIONS ODBC 2,0 umbenannt.|
|SQL_MAX_IDENTIFIER_LEN|3.0|Ein sqlusmallint-Wert, der die maximale Größe in Zeichen angibt, die von der Datenquelle für benutzerdefinierte Namen unterstützt wird.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 18 zurück. Ein mit der conps-Konformität zwischen Ebenen-konformen Treiber gibt mindestens 128 zurück.|
|SQL_MAX_INDEX_SIZE|2.0|Ein SQLUINTEGER-Wert, der die maximale Anzahl von Bytes angibt, die in den kombinierten Feldern eines Indexes zulässig sind. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.|
|SQL_MAX_PROCEDURE_NAME_LEN|1.0|Ein sqlusmallint-Wert, der die maximale Länge eines Prozedur namens in der Datenquelle angibt. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.|
|SQL_MAX_ROW_SIZE|2.0|Ein SQLUINTEGER-Wert, der die maximale Länge einer einzelnen Zeile in einer Tabelle angibt. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 2.000 zurück. Ein mit der conps-Konformität zwischen Ebenen-konformen Treiber gibt mindestens 8.000 zurück.|
|SQL_MAX_ROW_SIZE_INCLUDES_LONG|3.0|Eine Zeichenfolge: "Y", wenn die maximale Zeilengröße, die für den SQL_MAX_ROW_SIZE informationentyp zurückgegeben wird, die Länge aller SQL_LONGVARCHAR und SQL_LONGVARBINARY Spalten in der Zeile enthält. Andernfalls "N".|
|SQL_MAX_SCHEMA_NAME_LEN|1.0|Ein sqlusmallint-Wert, der die maximale Länge eines Schema namens in der Datenquelle angibt. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 18 zurück. Ein mit der conps-Konformität zwischen Ebenen-konformen Treiber gibt mindestens 128 zurück.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_MAX_OWNER_NAME_LEN ODBC 2,0 umbenannt.|
|SQL_MAX_STATEMENT_LEN|2.0|Ein SQLUINTEGER-Wert, der die maximale Länge (Anzahl der Zeichen, einschließlich Leerzeichen) einer SQL-Anweisung angibt. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.|
|SQL_MAX_TABLE_NAME_LEN|1.0|Ein sqlusmallint-Wert, der die maximale Länge eines Tabellennamens in der Datenquelle angibt. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 18 zurück. Ein mit der conps-Konformität zwischen Ebenen-konformen Treiber gibt mindestens 128 zurück.|
|SQL_MAX_TABLES_IN_SELECT|2.0|Ein sqlusmallint-Wert, der die maximale Anzahl von Tabellen angibt, die in der **from** -Klausel einer **Select** -Anweisung zulässig sind. Wenn kein angegebenes Limit vorliegt oder das Limit unbekannt ist, wird dieser Wert auf 0 festgelegt.<br/><br/>Ein mit der PPS-Eintrags Ebene übereinter Treiber gibt mindestens 15 zurück. Ein mit der conps-Konformität zwischen Ebenen-konformen Treiber gibt mindestens 50 zurück.|
|SQL_MAX_USER_NAME_LEN|2.0|Ein sqlusmallint-Wert, der die maximale Länge eines Benutzernamens in der Datenquelle angibt. Wenn keine maximale Länge vorliegt oder die Länge unbekannt ist, wird dieser Wert auf 0 (null) festgelegt.|
|SQL_MULT_RESULT_SETS|1.0|Eine Zeichenfolge: "Y", wenn die Datenquelle mehrere Resultsets unterstützt, "N", wenn dies nicht der Fall ist.<br/><br/>Weitere Informationen zu mehreren Resultsets finden Sie unter [mehrere Ergebnisse](../develop-app/multiple-results.md).|
|SQL_MULTIPLE_ACTIVE_TXN|1.0|Eine Zeichenfolge "Y", wenn der Treiber mehr als eine aktive Transaktion gleichzeitig unterstützt, "N", wenn jeweils nur eine Transaktion aktiv sein kann.<br/><br/>Die für diesen Informationstyp zurückgegebenen Informationen gelten nicht für verteilte Transaktionen.|
|SQL_NEED_LONG_DATA_LEN|2.0|Eine Zeichenfolge: "Y", wenn die Datenquelle die Länge eines Long-Datenwerts (der Datentyp ist SQL_LONGVARCHAR, SQL_LONGVARBINARY oder ein langer Datenquellen spezifischer Datentyp) benötigt, bevor dieser Wert an die Datenquelle gesendet wird, andernfalls "N", wenn dies nicht der Fall ist. Weitere Informationen finden Sie unter [SQLBindParameter-Funktion](sqlbindparameter-function.md) und [SQLSetPos-Funktion](sqlsetpos-function.md).|
|SQL_NON_NULLABLE_COLUMNS|1.0|Ein sqlusmallint-Wert, der angibt, ob die Datenquelle in Spalten not NULL unterstützt:<br/>SQL_NNC_NULL = alle Spalten müssen NULL-Werte zulassen.<br/>SQL_NNC_NON_NULL = Spalten dürfen keine NULL-Werte zulassen. (Die Datenquelle unterstützt die **not NULL** -Spalten Einschränkung in **CREATE TABLE** -Anweisungen.)<br/><br/>Ein mit SQL-92 Entry Level-konformitäer Treibers wird SQL_NNC_NON_NULL zurückgegeben.|
|SQL_NULL_COLLATION|2.0|Ein sqlusmallint-Wert, der angibt, wo NULL-Werte in einem Resultset sortiert werden:<br/>SQL_NC_END = NULL-Werten werden am Ende des Resultsets sortiert, unabhängig von den Schlüsselwörtern ASC oder Entsc.<br/>SQL_NC_HIGH = NULL-Werten werden abhängig von den Schlüsselwörtern ASC oder Debug am höchsten Ende des Resultsets sortiert.<br/>SQL_NC_LOW = NULL-Werten werden am unteren Ende des Resultsets sortiert, abhängig von den Schlüsselwörtern ASC oder Entsc.<br/>SQL_NC_START = NULL-Werten werden am Anfang des Resultsets sortiert, unabhängig von den Schlüsselwörtern ASC oder Entsc.|
|SQL_NUMERIC_FUNCTIONS|1.0|Hinweis: der Informationstyp wurde in ODBC 1,0 eingeführt. jede Bitmaske ist mit der Version gekennzeichnet, in der Sie eingeführt wurde.<br/><br/>Eine SQLUINTEGER-Bitmaske, die die numerischen Skalarfunktionen auflistet, die vom Treiber und der zugeordneten Datenquelle unterstützt werden.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche numerischen Funktionen unterstützt werden:<br/>SQL_FN_NUM_ABS (ODBC 1,0)<br/>SQL_FN_NUM_ACOS (ODBC 1,0)<br/>SQL_FN_NUM_ASIN (ODBC 1,0)<br/>SQL_FN_NUM_ATAN (ODBC 1,0)<br/>SQL_FN_NUM_ATAN2 (ODBC 1,0)<br/>SQL_FN_NUM_CEILING (ODBC 1,0)<br/>SQL_FN_NUM_COS (ODBC 1,0)<br/>SQL_FN_NUM_COT (ODBC 1,0)<br/>SQL_FN_NUM_DEGREES (ODBC 2,0)<br/>SQL_FN_NUM_EXP (ODBC 1,0)<br/>SQL_FN_NUM_FLOOR (ODBC 1,0)<br/>SQL_FN_NUM_LOG (ODBC 1,0)<br/>SQL_FN_NUM_LOG10 (ODBC 2,0)<br/>SQL_FN_NUM_MOD (ODBC 1,0)<br/>SQL_FN_NUM_PI (ODBC 1,0)<br/>SQL_FN_NUM_POWER (ODBC 2,0)<br/>SQL_FN_NUM_RADIANS (ODBC 2,0)<br/>SQL_FN_NUM_RAND (ODBC 1,0)<br/>SQL_FN_NUM_ROUND (ODBC 2,0)<br/>SQL_FN_NUM_SIGN (ODBC 1,0)<br/>SQL_FN_NUM_SIN (ODBC 1,0)<br/>SQL_FN_NUM_SQRT (ODBC 1,0)<br/>SQL_FN_NUM_TAN (ODBC 1,0)<br/>SQL_FN_NUM_TRUNCATE (ODBC 2,0)|
|SQL_ODBC_INTERFACE_CONFORMANCE|3.0|Ein SQLUINTEGER-Wert, der die Ebene der ODBC 3 *. x* -Schnittstelle angibt, der der Treiber entspricht.<br/><br/>SQL_OIC_CORE: die minimale Ebene, der alle ODBC-Treiber entsprechen sollen. Diese Ebene umfasst grundlegende Schnittstellen Elemente, wie z. b. Verbindungsfunktionen, Funktionen zum Vorbereiten und Ausführen einer SQL-Anweisung, grundlegende resultsetmetadatenfunktionen, grundlegende Katalog Funktionen usw.<br/>SQL_OIC_LEVEL1: eine Ebene, einschließlich der Kernfunktionen der Kompatibilitäts Ebene, sowie scrollfähige Cursor, Lesezeichen, positionierte Updates und Löschungen usw.<br/>SQL_OIC_LEVEL2: eine Ebene, einschließlich der Standardfunktionen der Kompatibilitäts Ebene der Ebene 1 sowie erweiterter Features wie z. b. sensible Cursor aktualisieren, löschen und aktualisieren nach Lesezeichen Unterstützung für gespeicherte Prozeduren Katalog Funktionen für Primär-und Fremdschlüssel; Unterstützung für mehrere Kataloge; Und so weiter.<br/><br/>Weitere Informationen finden Sie unter [Schnittstellen](../develop-app/interface-conformance-levels.md)Übereinstimmungs Ebenen.|
|SQL_ODBC_VER|1.0|Eine Zeichenfolge mit der Version von ODBC, der der Treiber-Manager entspricht. Die Version hat das Format # #. # #. 0000, wobei die ersten beiden Ziffern die Hauptversion und die nächsten zwei Ziffern die neben Version sind. Dies wird nur im Treiber-Manager implementiert.|
|SQL_OJ_CAPABILITIES|2,01|Eine SQLUINTEGER-Bitmaske, die die Typen von äußeren Joins auflistet, die vom Treiber und der Datenquelle unterstützt werden. Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Typen unterstützt werden:<br/>SQL_OJ_LEFT = Left Outer Joins werden unterstützt.<br/>SQL_OJ_RIGHT = Rechte äußere Joins werden unterstützt.<br/>SQL_OJ_FULL = vollständige äußere Joins werden unterstützt.<br/>SQL_OJ_NESTED = eingefügte äußere Joins werden unterstützt.<br/>SQL_OJ_NOT_ORDERED = die Spaltennamen in der ON-Klausel des äußeren Joins müssen sich nicht in derselben Reihenfolge wie die entsprechenden Tabellennamen in der **äußeren Join** -Klausel befinden.<br/>SQL_OJ_INNER = die innere Tabelle (die Rechte Tabelle in einem Left Outer Join oder in der linken Tabelle in einem rechten äußeren Join) kann auch in einem inneren Join verwendet werden. Dies gilt nicht für vollständige äußere Joins, die keine innere Tabelle aufweisen.<br/>SQL_OJ_ALL_COMPARISON_OPS = der Vergleichs Operator in der ON-Klausel kann einer der ODBC-Vergleichs Operatoren sein. Wenn dieses Bit nicht festgelegt ist, kann nur der Vergleichs Operator "gleich" (=) in äußeren Joins verwendet werden.<br/><br/>Wenn keine dieser Optionen als unterstützt zurückgegeben wird, wird keine Outer Join-Klausel unterstützt.<br/><br/>Informationen zur Unterstützung von relationalen joinoperatoren in einer SELECT-Anweisung, wie von SQL-92 definiert, finden Sie unter SQL_SQL92_RELATIONAL_JOIN_OPERATORS.|
|SQL_ORDER_BY_COLUMNS_IN_SELECT|2.0|Eine Zeichenfolge: "Y", wenn die Spalten in der **Order by** -Klausel in der SELECT-Liste enthalten sein müssen. andernfalls "N".|
|SQL_PARAM_ARRAY_ROW_COUNTS|3.0|Ein SQLUINTEGER-Element, das die Eigenschaften des Treibers bezüglich der Verfügbarkeit der Zeilen Anzahl in einer parametrisierten Ausführung auflistet. Weist die folgenden Werte auf:<br/>SQL_PARC_BATCH = einzelne Zeilen Anzahl ist für jeden Parametersatz verfügbar. Dies entspricht konzeptionell dem Treiber, der einen Batch von SQL-Anweisungen erzeugt, eine für jeden Parametersatz im Array. Erweiterte Fehlerinformationen können mit dem Feld SQL_PARAM_STATUS_PTR Deskriptor abgerufen werden.<br/>SQL_PARC_NO_BATCH = es ist nur eine Zeilen Anzahl verfügbar. Dies ist die kumulierte Zeilen Anzahl, die sich aus der Ausführung der-Anweisung für das gesamte Array von Parametern ergibt. Dies entspricht konzeptionell der Behandlung der Anweisung und des kompletten Parameter Arrays als eine atomarische Einheit. Fehler werden genauso behandelt, als wenn eine-Anweisung ausgeführt wurde.|
|SQL_PARAM_ARRAY_SELECTS|3.0|Ein SQLUINTEGER-Element, das die Eigenschaften des Treibers in Bezug auf die Verfügbarkeit von Resultsets in einer parametrisierten Ausführung auflistet. Weist die folgenden Werte auf:<br/>SQL_PAS_BATCH = es ist ein Resultset pro Parametersatz verfügbar. Dies entspricht konzeptionell dem Treiber, der einen Batch von SQL-Anweisungen erzeugt, eine für jeden Parametersatz im Array.<br/>SQL_PAS_NO_BATCH = es ist nur ein Resultset verfügbar, das das kumulative Resultset darstellt, das sich aus der Ausführung der-Anweisung für das vollständige Array von Parametern ergibt. Dies entspricht konzeptionell der Behandlung der Anweisung und des kompletten Parameter Arrays als eine atomarische Einheit.<br/>SQL_PAS_NO_SELECT = ein Treiber lässt nicht zu, dass eine Resultset-Generierungs Anweisung mit einem Array von Parametern ausgeführt wird.|
|SQL_POS_OPERATIONS|2.0|Eine SQLINTEGER-Bitmaske, die die Unterstützungs Vorgänge in **SQLSetPos**auflistet.<br/><br/>Die folgenden Bitmasken werden mit dem-Flag verwendet, um zu bestimmen, welche Optionen unterstützt werden.<br/>SQL_POS_POSITION (ODBC 2,0)<br/>SQL_POS_REFRESH (ODBC 2,0)<br/>SQL_POS_UPDATE (ODBC 2,0)<br/>SQL_POS_DELETE (ODBC 2,0)<br/>SQL_POS_ADD (ODBC 2,0)|
|SQL_PROCEDURE_TERM|1.0|Eine Zeichenfolge mit dem Namen des Datenquellen Herstellers für eine Prozedur. Beispiel: "Daten Bank Prozedur", "gespeicherte Prozedur", "Prozedur", "Paket" oder "gespeicherte Abfrage".|
|SQL_PROCEDURES|1.0|Eine Zeichenfolge: "Y", wenn die Datenquelle Prozeduren unterstützt und der Treiber die ODBC-Prozedur Aufruf Syntax unterstützt. Andernfalls "N".|
|SQL_QUOTED_IDENTIFIER_CASE|2.0|Einen sqlusmallint-Wert wie folgt:<br/>Bei SQL_IC_UPPER = Bezeichner in Anführungszeichen in SQL wird die Groß-/Kleinschreibung nicht beachtet, und Sie werden in Großbuchstaben im System Katalog gespeichert.<br/>Bei SQL_IC_LOWER = Bezeichner in Anführungszeichen in SQL wird die Groß-/Kleinschreibung nicht beachtet und in Kleinbuchstaben im System Katalog gespeichert.<br/>Bei SQL_IC_SENSITIVE = Bezeichner in Anführungszeichen in SQL wird die Groß-/Kleinschreibung beachtet, und Sie werden im System Katalog gemischt gespeichert. (In einer SQL-92-kompatiblen Datenbank wird bei Bezeichnern in Anführungszeichen immer die Groß-/Kleinschreibung beachtet.)<br/>Bei SQL_IC_MIXED = Bezeichner in Anführungszeichen in SQL wird die Groß-/Kleinschreibung nicht beachtet, und die Daten werden in gemischten Fällen im System Katalog gespeichert.<br/><br/>Ein mit SQL-92 Entry Level-konformitäer Treibers gibt immer SQL_IC_SENSITIVE zurück.|
|SQL_ROW_UPDATES|1.0|Eine Zeichenfolge: "Y", wenn ein keysetgesteuerter oder gemischter Cursor Zeilen Versionen oder Werte für alle abgerufenen Zeilen beibehält und daher alle Updates erkennen kann, die von einem Benutzer seit dem letzten Abruf der Zeile an einer Zeile vorgenommen wurden. (Dies gilt nur für Updates, nicht für Löschungen oder Einfügungen.) Der Treiber kann das SQL_ROW_UPDATED-Flag zum Zeilen Status Array zurückgeben, wenn **SQLFetchScroll** aufgerufen wird. Andernfalls "N".|
|SQL_SCHEMA_TERM|1.0|Eine Zeichenfolge mit dem Namen des Datenquellen Herstellers für ein Schema. Beispiel: "Owner", "Authorization ID" oder "Schema".<br/><br/>Die Zeichenfolge kann in groß-, klein-oder gemischter Groß-/Kleinschreibung zurückgegeben werden.<br/><br/>Ein mit SQL-92 Entry Level-konformitäer Treibers gibt immer "Schema" zurück.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_OWNER_TERM ODBC 2,0 umbenannt.|
|SQL_SCHEMA_USAGE|2.0|Eine SQLUINTEGER-Bitmaske, die die-Anweisungen auflistet, in denen Schemas verwendet werden können:<br/>SQL_SU_DML_STATEMENTS = Schemas werden in allen Anweisungen für die Daten Bearbeitungs Sprache unterstützt: **Select**, **Insert**, **Update**, **Delete**und falls unterstützt, **Wählen Sie für Update** -und positionierte UPDATE-und DELETE-Anweisungen aus.<br/>SQL_SU_PROCEDURE_INVOCATION = Schemas werden in der Anweisung zum Aufrufen von ODBC-Prozeduren unterstützt.<br/>SQL_SU_TABLE_DEFINITION = Schemas werden in allen Tabellen Definitions Anweisungen unterstützt: **CREATE TABLE**, **CREATE VIEW**, **ALTER TABLE**, **DROP TABLE**und **Drop View**.<br/>SQL_SU_INDEX_DEFINITION = Schemas werden in allen Index Definitions Anweisungen unterstützt: **Create Index** und **Drop Index**.<br/>SQL_SU_PRIVILEGE_DEFINITION = Schemas werden in allen Berechtigungs Definitions Anweisungen unterstützt: **Grant** und **Widerruf**.<br/><br/>Ein in SQL-92 Eintrags Level übergebender Treiber gibt immer die Optionen SQL_SU_DML_STATEMENTS, SQL_SU_TABLE_DEFINITION und SQL_SU_PRIVILEGE_DEFINITION zurück, wie unterstützt.<br/><br/>Dieser *InfoType* wurde für ODBC 3,0 von der *InfoType* -SQL_OWNER_USAGE ODBC 2,0 umbenannt.|
|SQL_SCROLL_OPTIONS|1.0|Hinweis: der Informationstyp wurde in ODBC 1,0 eingeführt. jede Bitmaske ist mit der Version gekennzeichnet, in der Sie eingeführt wurde.<br/><br/>Eine SQLUINTEGER-Bitmaske, die die Bild Lauf Optionen auflistet, die für scrollbare Cursor unterstützt werden.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Optionen unterstützt werden:<br/>SQL_SO_FORWARD_ONLY = der Cursor führt einen Bildlauf nach oben aus. (ODBC 1,0)<br/>SQL_SO_STATIC = die Daten im Resultset sind statisch. (ODBC 2,0)<br/>SQL_SO_KEYSET_DRIVEN = der Treiber speichert und verwendet die Schlüssel für jede Zeile im Resultset. (ODBC 1,0)<br/>SQL_SO_DYNAMIC = der Treiber behält die Schlüssel für jede Zeile im Rowset bei (die Keysetgröße ist identisch mit der Rowsetgröße). (ODBC 1,0)<br/>SQL_SO_MIXED = der Treiber behält die Schlüssel für jede Zeile im Keyset bei, und die Keysetgröße ist größer als die Rowsetgröße. Der Cursor ist keysetgesteuert innerhalb des Keysets und dynamisch außerhalb des Keysets. (ODBC 1,0)<br/><br/>Informationen zu scrollfähigen Cursorn finden Sie unter [scrollfähige Cursor](../develop-app/scrollable-cursors.md).|
|SQL_SEARCH_PATTERN_ESCAPE|1.0|Eine Zeichenfolge, die angibt, was der Treiber als Escapezeichen unterstützt, das die Verwendung des Muster Vergleichs Metazeichen Unterstrich (_) und Prozentzeichen (%) ermöglicht. als gültige Zeichen in Suchmustern. Dieses Escapezeichen gilt nur für die Katalog Funktionsargumente, die Such Zeichenfolgen unterstützen. Wenn diese Zeichenfolge leer ist, unterstützt der Treiber kein Escapezeichen für das Suchmuster.<br/><br/>Da dieser Informationstyp keine allgemeine Unterstützung für das Escapezeichen im **like** -Prädikat angibt, enthält SQL-92 keine Anforderungen für diese Zeichenfolge.<br/><br/>Dieser *InfoType* ist auf Katalog Funktionen beschränkt. Eine Beschreibung der Verwendung des Escapezeichens in Suchmuster Zeichenfolgen finden Sie unter [Muster Wert Argumente](../develop-app/pattern-value-arguments.md).|
|SQL_SERVER_NAME|1.0|Eine Zeichenfolge mit dem tatsächlichen Datenquellen spezifischen Servernamen; nützlich, wenn ein Datenquellen Name während **SQLCONNECT**, **SQLDriverConnect**und **sqlbrowseconnetct**verwendet wird.|
|SQL_SPECIAL_CHARACTERS|2.0|Eine Zeichenfolge, die alle Sonderzeichen enthält (d. h. alle Zeichen mit Ausnahme von a bis z, a bis z, 0 bis 9 und Unterstriche), die in einem Bezeichnernamen (z. b. Tabellenname, Spaltenname oder Indexname) für die Datenquelle verwendet werden können. Beispiel: "# $ ^". Wenn ein Bezeichner mindestens ein Zeichen enthält, muss der Bezeichner ein Begrenzungs Bezeichner sein.|
|SQL_SQL_CONFORMANCE|3.0|Ein SQLUINTEGER-Wert, der die Ebene von SQL-92 angibt, die vom Treiber unterstützt wird:<br/>SQL_SC_SQL92_ENTRY = Eintrags Ebene SQL-92-kompatibel.<br/>SQL_SC_FIPS127_2_TRANSITIONAL = mit der Übergangsstufe 127-2 = mit der Übergangsstufe kompatibel.<br/>SQL_SC_SQL92_FULL = vollständig SQL-92-kompatibel.<br/>SQL_SC_ SQL92_INTERMEDIATE = Zwischenstufe SQL-92-kompatibel.|
|SQL_SQL92_DATETIME_FUNCTIONS|3.0|Eine SQLUINTEGER-Bitmaske, die die DateTime-Skalarfunktionen auflistet, die vom Treiber und der zugeordneten Datenquelle unterstützt werden, wie in SQL-92 definiert.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche datetime-Funktionen unterstützt werden:<br/>SQL_SDF_CURRENT_DATE<br/>SQL_SDF_CURRENT_TIME<br/>SQL_SDF_CURRENT_TIMESTAMP|
|SQL_SQL92_FOREIGN_KEY_DELETE_RULE|3.0|Eine SQLUINTEGER-Bitmaske, die die Regeln auflistet, die für einen Fremdschlüssel in einer **Delete** -Anweisung unterstützt werden, wie in SQL-92 definiert.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln von der Datenquelle unterstützt werden:<br/>SQL_SFKD_CASCADE<br/>SQL_SFKD_NO_ACTION<br/>SQL_SFKD_SET_DEFAULT<br/>SQL_SFKD_SET_NULL<br/><br/>Ein mit der Anwendung für die Übergangs Ebene übergebender PPS gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_SQL92_FOREIGN_KEY_UPDATE_RULE|3.0|Eine SQLUINTEGER-Bitmaske, die die Regeln auflistet, die für einen Fremdschlüssel in einer **Update** -Anweisung unterstützt werden, wie in SQL-92 definiert.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln von der Datenquelle unterstützt werden:<br/>SQL_SFKU_CASCADE<br/>SQL_SFKU_NO_ACTION<br/>SQL_SFKU_SET_DEFAULT<br/>SQL_SFKU_SET_NULL<br/><br/>Ein vollständig konformen SQL-92-Treiber gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_SQL92_GRANT|3.0|Eine SQLUINTEGER-Bitmaske, die die in der **Grant** -Anweisung unterstützten Klauseln auflistet, wie in SQL-92 definiert.<br/><br/>Die SQL-92-oder FPS-Konformitätsstufe, bei der diese Funktion unterstützt werden muss, wird in Klammern neben den einzelnen Bitmasken angezeigt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln von der Datenquelle unterstützt werden:<br/>SQL_SG_DELETE_TABLE (Einstiegsebene)<br/>SQL_SG_INSERT_COLUMN (Zwischenebene)<br/>SQL_SG_INSERT_TABLE (Einstiegsebene)<br/>SQL_SG_REFERENCES_TABLE (Einstiegsebene)<br/>SQL_SG_REFERENCES_COLUMN (Einstiegsebene)<br/>SQL_SG_SELECT_TABLE (Einstiegsebene)<br/>SQL_SG_UPDATE_COLUMN (Einstiegsebene)<br/>SQL_SG_UPDATE_TABLE (Einstiegsebene)<br/>SQL_SG_USAGE_ON_DOMAIN (fps-Übergangs Ebene)<br/>SQL_SG_USAGE_ON_CHARACTER_SET (fps-Übergangs Ebene)<br/>SQL_SG_USAGE_ON_COLLATION (fps-Übergangs Ebene)<br/>SQL_SG_USAGE_ON_TRANSLATION (fps-Übergangs Ebene)<br/>SQL_SG_WITH_GRANT_OPTION (Einstiegsebene)|
|SQL_SQL92_NUMERIC_VALUE_FUNCTIONS|3.0|Eine SQLUINTEGER-Bitmaske, die die Skalarfunktionen des numerischen Werts auflistet, die vom Treiber und der zugeordneten Datenquelle unterstützt werden, wie in SQL-92 definiert.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche numerischen Funktionen unterstützt werden:<br/>SQL_SNVF_BIT_LENGTH<br/>SQL_SNVF_CHAR_LENGTH<br/>SQL_SNVF_CHARACTER_LENGTH<br/>SQL_SNVF_EXTRACT<br/>SQL_SNVF_OCTET_LENGTH<br/>SQL_SNVF_POSITION|
|SQL_SQL92_PREDICATES|3.0|Eine SQLUINTEGER-Bitmaske, die die Prädikate auflistet, die in einer **Select** -Anweisung unterstützt werden, wie in SQL-92 definiert.<br/><br/>Die SQL-92-oder FPS-Konformitätsstufe, bei der diese Funktion unterstützt werden muss, wird in Klammern neben den einzelnen Bitmasken angezeigt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Optionen von der Datenquelle unterstützt werden:<br/>SQL_SP_BETWEEN (Einstiegsebene)<br/>SQL_SP_COMPARISON (Einstiegsebene)<br/>SQL_SP_EXISTS (Einstiegsebene)<br/>SQL_SP_IN (Einstiegsebene)<br/>SQL_SP_ISNOTNULL (Einstiegsebene)<br/>SQL_SP_ISNULL (Einstiegsebene)<br/>SQL_SP_LIKE (Einstiegsebene)<br/>SQL_SP_MATCH_FULL (vollständig)<br/>SQL_SP_MATCH_PARTIAL (vollständig)<br/>SQL_SP_MATCH_UNIQUE_FULL (vollständig)<br/>SQL_SP_MATCH_UNIQUE_PARTIAL (vollständig)<br/>SQL_SP_OVERLAPS (fps-Übergangs Ebene)<br/>SQL_SP_QUANTIFIED_COMPARISON (Einstiegsebene)<br/>SQL_SP_UNIQUE (Einstiegsebene)|
|SQL_SQL92_RELATIONAL_JOIN_OPERATORS|3.0|Eine SQLUINTEGER-Bitmaske, die die in einer **Select** -Anweisung unterstützten relationalen joinoperatoren auflistet, wie in SQL-92 definiert.<br/><br/>Die SQL-92-oder FPS-Konformitätsstufe, bei der diese Funktion unterstützt werden muss, wird in Klammern neben den einzelnen Bitmasken angezeigt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Optionen von der Datenquelle unterstützt werden:<br/>SQL_SRJO_CORRESPONDING_CLAUSE (Zwischenebene)<br/>SQL_SRJO_CROSS_JOIN (vollständig)<br/>SQL_SRJO_EXCEPT_JOIN (Zwischenebene)<br/>SQL_SRJO_FULL_OUTER_JOIN (Zwischenebene)<br/>SQL_SRJO_INNER_JOIN (fps-Übergangs Ebene)<br/>SQL_SRJO_INTERSECT_JOIN (Zwischenebene)<br/>SQL_SRJO_LEFT_OUTER_JOIN (fps-Übergangs Ebene)<br/>SQL_SRJO_NATURAL_JOIN (fps-Übergangs Ebene)<br/>SQL_SRJO_RIGHT_OUTER_JOIN (fps-Übergangs Ebene)<br/>SQL_SRJO_UNION_JOIN (vollständig)<br/><br/>SQL_SRJO_INNER_JOIN gibt die Unterstützung für die **innere** joinsyntax an, nicht für die innere joinfunktion. Die Unterstützung für die **innere** joinsyntax ist "PPS Transition", wohingegen die Unterstützung für die innere joinfunktion " **Entry**" ist.|
|SQL_SQL92_REVOKE|3.0|Eine SQLUINTEGER-Bitmaske, die die Klauseln aufzählt, die in der von der Datenquelle unterstützten Anweisung " **Widerruf** " unterstützt werden, wie in SQL-92 definiert.<br/><br/>Die SQL-92-oder FPS-Konformitätsstufe, bei der diese Funktion unterstützt werden muss, wird in Klammern neben den einzelnen Bitmasken angezeigt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Klauseln von der Datenquelle unterstützt werden:<br/>SQL_SR_CASCADE (fps-Übergangs Ebene)<br/>SQL_SR_DELETE_TABLE (Einstiegsebene)<br/>SQL_SR_GRANT_OPTION_FOR (Zwischenebene)<br/>SQL_SR_INSERT_COLUMN (Zwischenebene)<br/>SQL_SR_INSERT_TABLE (Einstiegsebene)<br/>SQL_SR_REFERENCES_COLUMN (Einstiegsebene)<br/>SQL_SR_REFERENCES_TABLE (Einstiegsebene)<br/>SQL_SR_RESTRICT (fps-Übergangs Ebene)<br/>SQL_SR_SELECT_TABLE (Einstiegsebene)<br/>SQL_SR_UPDATE_COLUMN (Einstiegsebene)<br/>SQL_SR_UPDATE_TABLE (Einstiegsebene)<br/>SQL_SR_USAGE_ON_DOMAIN (fps-Übergangs Ebene)<br/>SQL_SR_USAGE_ON_CHARACTER_SET (fps-Übergangs Ebene)<br/>SQL_SR_USAGE_ON_COLLATION (fps-Übergangs Ebene)<br/>SQL_SR_USAGE_ON_TRANSLATION (fps-Übergangs Ebene)|
|SQL_SQL92_ROW_VALUE_CONSTRUCTOR|3.0|Eine SQLUINTEGER-Bitmaske, die die in einer **Select** -Anweisung unterstützten Zeilen Wert-konstruktorausdrücke auflistet, wie in SQL-92 definiert. Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Optionen von der Datenquelle unterstützt werden:<br/>SQL_SRVC_VALUE_EXPRESSION<br/>SQL_SRVC_NULL<br/>SQL_SRVC_DEFAULT<br/>SQL_SRVC_ROW_SUBQUERY|
|SQL_SQL92_STRING_FUNCTIONS|3.0|Eine SQLUINTEGER-Bitmaske, die die skalaren Zeichen folgen Funktionen auflistet, die vom Treiber und der zugeordneten Datenquelle unterstützt werden, wie in SQL-92 definiert.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Zeichen folgen Funktionen unterstützt werden:<br/>SQL_SSF_CONVERT<br/>SQL_SSF_LOWERSQL_SSF_UPPER<br/>SQL_SSF_SUBSTRING<br/>SQL_SSF_TRANSLATE<br/>SQL_SSF_TRIM_BOTH<br/>SQL_SSF_TRIM_LEADING<br/>SQL_SSF_TRIM_TRAILING|
|SQL_SQL92_VALUE_EXPRESSIONS|3.0|Eine SQLUINTEGER-Bitmaske, die die unterstützten Wert Ausdrücke auflistet, wie in SQL-92 definiert.<br/><br/>Die SQL-92-oder FPS-Konformitätsstufe, bei der diese Funktion unterstützt werden muss, wird in Klammern neben den einzelnen Bitmasken angezeigt.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Optionen von der Datenquelle unterstützt werden:<br/>SQL_SVE_CASE (Zwischenebene)<br/>SQL_SVE_CAST (fps-Übergangs Ebene)<br/>SQL_SVE_COALESCE (Zwischenebene)<br/>SQL_SVE_NULLIF (Zwischenebene)|
|SQL_STANDARD_CLI_CONFORMANCE|3.0|Eine SQLUINTEGER-Bitmaske, die den CLI-Standard-oder-Standardwert auflistet, dem der Treiber entspricht. Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Ebenen der Treiber erfüllt:<br/>SQL_SCC_XOPEN_CLI_VERSION1: der Treiber entspricht der Open Group CLI-Version 1.<br/>SQL_SCC_ISO92_CLI: der Treiber entspricht der ISO 92-CLI.|
|SQL_STATIC_CURSOR_ATTRIBUTES1|3.0|Eine SQLUINTEGER-Bitmaske, die die Attribute eines statischen Cursors beschreibt, die vom Treiber unterstützt werden. Diese Bitmaske enthält die erste Teilmenge von Attributen. die zweite Teilmenge finden Sie unter SQL_STATIC_CURSOR_ATTRIBUTES2.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Attribute unterstützt werden:<br/>SQL_CA1_NEXT<br/>SQL_CA1_ABSOLUTE<br/>SQL_CA1_RELATIVE<br/>SQL_CA1_BOOKMARK<br/>SQL_CA1_LOCK_NO_CHANGE<br/>SQL_CA1_LOCK_EXCLUSIVE<br/>SQL_CA1_LOCK_UNLOCK<br/>SQL_CA1_POS_POSITION<br/>SQL_CA1_POS_UPDATE<br/>SQL_CA1_POS_DELETE<br/>SQL_CA1_POS_REFRESH<br/>SQL_CA1_POSITIONED_UPDATE<br/>SQL_CA1_POSITIONED_DELETE<br/>SQL_CA1_SELECT_FOR_UPDATE<br/>SQL_CA1_BULK_ADD<br/>SQL_CA1_BULK_UPDATE_BY_BOOKMARK<br/>SQL_CA1_BULK_DELETE_BY_BOOKMARK<br/>SQL_CA1_BULK_FETCH_BY_BOOKMARK<br/><br/>Beschreibungen dieser Bitmasks finden Sie unter SQL_DYNAMIC_CURSOR_ATTRIBUTES1 (und Ersetzen des "statischen Cursors" für "dynamischer Cursor" in den Beschreibungen).<br/><br/>Ein SQL-92-zwischen Ebenen-konformen Treiber gibt in der Regel die Optionen SQL_CA1_NEXT, SQL_CA1_ABSOLUTE und SQL_CA1_RELATIVE zurück, die unterstützt werden, da der Treiber scrollbare Cursor durch die eingebettete SQL FETCH-Anweisung unterstützt. Da dadurch die zugrunde liegende SQL-Unterstützung nicht direkt bestimmt wird, werden scrollfähige Cursor möglicherweise nicht unterstützt, auch für einen zwischengeschalteten SQL-92-untergeordneten Treiber.|
|SQL_STATIC_CURSOR_ATTRIBUTES2|3.0|Eine SQLUINTEGER-Bitmaske, die die Attribute eines statischen Cursors beschreibt, die vom Treiber unterstützt werden. Diese Bitmaske enthält die zweite Teilmenge von Attributen. die erste Teilmenge finden Sie unter SQL_STATIC_CURSOR_ATTRIBUTES1.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Attribute unterstützt werden:<br/>SQL_CA2_READ_ONLY_CONCURRENCY<br/>SQL_CA2_LOCK_CONCURRENCY<br/>SQL_CA2_OPT_ROWVER_CONCURRENCY<br/>SQL_CA2_OPT_VALUES_CONCURRENCY<br/>SQL_CA2_SENSITIVITY_ADDITIONS<br/>SQL_CA2_SENSITIVITY_DELETIONS<br/>SQL_CA2_SENSITIVITY_UPDATES<br/>SQL_CA2_MAX_ROWS_SELECT<br/>SQL_CA2_MAX_ROWS_INSERT<br/>SQL_CA2_MAX_ROWS_DELETE<br/>SQL_CA2_MAX_ROWS_UPDATE<br/>SQL_CA2_MAX_ROWS_CATALOG<br/>SQL_CA2_MAX_ROWS_AFFECTS_ALL<br/>SQL_CA2_CRC_EXACT<br/>SQL_CA2_CRC_APPROXIMATE<br/>SQL_CA2_SIMULATE_NON_UNIQUE<br/>SQL_CA2_SIMULATE_TRY_UNIQUE<br/>SQL_CA2_SIMULATE_UNIQUE<br/><br/>Beschreibungen dieser Bitmasks finden Sie unter SQL_DYNAMIC_CURSOR_ATTRIBUTES2 (und Ersetzen des "statischen Cursors" für "dynamischer Cursor" in den Beschreibungen).|
|SQL_STRING_FUNCTIONS|1.0|Hinweis: der Informationstyp wurde in ODBC 1,0 eingeführt. jede Bitmaske ist mit der Version gekennzeichnet, in der Sie eingeführt wurde.<br/><br/>Eine SQLUINTEGER-Bitmaske, die die skalaren Zeichen folgen Funktionen auflistet, die vom Treiber und der zugeordneten Datenquelle unterstützt werden.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Zeichen folgen Funktionen unterstützt werden:<br/>SQL_FN_STR_ASCII (ODBC 1,0)<br/>SQL_FN_STR_BIT_LENGTH (ODBC 3,0)<br/>SQL_FN_STR_CHAR (ODBC 1,0)<br/>SQL_FN_STR_CHAR_LENGTH (ODBC 3,0)<br/>SQL_FN_STR_CHARACTER_LENGTH (ODBC 3,0)<br/>SQL_FN_STR_CONCAT (ODBC 1,0)<br/>SQL_FN_STR_DIFFERENCE (ODBC 2,0)<br/>SQL_FN_STR_INSERT (ODBC 1,0)<br/>SQL_FN_STR_LCASE (ODBC 1,0)<br/>SQL_FN_STR_LEFT (ODBC 1,0)<br/>SQL_FN_STR_LENGTH (ODBC 1,0)<br/>SQL_FN_STR_LOCATE (ODBC 1,0)<br/>SQL_FN_STR_LTRIM (ODBC 1,0)<br/>SQL_FN_STR_OCTET_LENGTH (ODBC 3,0)<br/>SQL_FN_STR_POSITION (ODBC 3,0)<br/>SQL_FN_STR_REPEAT (ODBC 1,0)<br/>SQL_FN_STR_REPLACE (ODBC 1,0)<br/>SQL_FN_STR_RIGHT (ODBC 1,0)<br/>SQL_FN_STR_RTRIM (ODBC 1,0)<br/>SQL_FN_STR_SOUNDEX (ODBC 2,0)<br/>SQL_FN_STR_SPACE (ODBC 2,0)<br/>SQL_FN_STR_SUBSTRING (ODBC 1,0)<br/>SQL_FN_STR_UCASE (ODBC 1,0)<br/><br/>Wenn eine Anwendung die "Skalarfunktion **Suchen** " mit den Argumenten " *string_exp1*", " *string_exp2*" und " *Start* " abrufen kann, gibt der Treiber die SQL_FN_STR_LOCATE Bitmaske zurück. Wenn eine Anwendung die Skalarfunktion suchen nur mit den *string_exp1* -und *string_exp2* -Argumenten aufzurufen kann, gibt der Treiber die SQL_FN_STR_LOCATE_2 Bitmaske zurück. Treiber, die die Skalarfunktion **Suchen** vollständig unterstützen, geben beide Bitmasken zurück.<br/><br/>(Weitere Informationen finden Sie unter [Zeichen folgen Funktionen](../appendixes/string-functions.md) in Anhang E, "skalare Funktionen".)|
|SQL_SUBQUERIES|2.0|Eine SQLUINTEGER-Bitmaske, die die Prädikate auflistet, die Unterabfragen unterstützen:<br/>SQL_SQ_CORRELATED_SUBQUERIES<br/>SQL_SQ_COMPARISON<br/>SQL_SQ_EXISTS<br/>SQL_SQ_INSQL_SQ_QUANTIFIED<br/><br/>Die SQL_SQ_CORRELATED_SUBQUERIES Bitmaske gibt an, dass alle Prädikate, die Unterabfragen unterstützen, korrelierte Unterabfragen unterstützen<br/><br/>Ein mit SQL-92 Entry Level-konformitäer Treibers gibt immer eine Bitmaske zurück, in der alle diese Bits festgelegt sind.|
|SQL_SYSTEM_FUNCTIONS|1.0|Eine SQLUINTEGER-Bitmaske, die die skalaren Systemfunktionen auflistet, die vom Treiber und der zugehörigen Datenquelle unterstützt werden.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Systemfunktionen unterstützt werden:<br/>SQL_FN_SYS_DBNAME<br/>SQL_FN_SYS_IFNULL<br/>SQL_FN_SYS_USERNAME|
|SQL_TABLE_TERM|1.0|Eine Zeichenfolge mit dem Namen des Datenquellen Herstellers für eine Tabelle. Beispiel: "Table" oder "file".<br/><br/>Diese Zeichenfolge kann groß, klein oder gemischt sein.<br/><br/>Ein mit SQL-92 Entry Level-konformitäer Treibers gibt immer "Table" zurück.|
|SQL_TIMEDATE_ADD_INTERVALS|2.0|Eine SQLUINTEGER-Bitmaske, die die Zeitstempel Intervalle auflistet, die vom Treiber und der zugehörigen Datenquelle für die timestampadd-Skalarfunktion unterstützt werden.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Intervalle unterstützt werden:<br/>SQL_FN_TSI_FRAC_SECOND<br/>SQL_FN_TSI_SECOND<br/>SQL_FN_TSI_MINUTE<br/>SQL_FN_TSI_HOUR<br/>SQL_FN_TSI_DAY<br/>SQL_FN_TSI_WEEK<br/>SQL_FN_TSI_MONTH<br/>SQL_FN_TSI_QUARTER<br/>SQL_FN_TSI_YEAR<br/><br/>Ein mit dem Operator für die Übergangs Ebene Übereinstimmung mit PPS gibt immer eine Bitmaske zurück, in der alle diese Bits festgelegt sind.|
|SQL_TIMEDATE_DIFF_INTERVALS|2.0|Eine SQLUINTEGER-Bitmaske, die die Zeitstempel Intervalle auflistet, die vom Treiber und der zugeordneten Datenquelle für die timestampdiff-Skalarfunktion unterstützt werden.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Intervalle unterstützt werden:<br/>SQL_FN_TSI_FRAC_SECOND<br/>SQL_FN_TSI_SECOND<br/>SQL_FN_TSI_MINUTE<br/>SQL_FN_TSI_HOUR<br/>SQL_FN_TSI_DAY<br/>SQL_FN_TSI_WEEK<br/>SQL_FN_TSI_MONTH<br/>SQL_FN_TSI_QUARTER<br/>SQL_FN_TSI_YEAR<br/><br/>Ein mit dem Operator für die Übergangs Ebene Übereinstimmung mit PPS gibt immer eine Bitmaske zurück, in der alle diese Bits festgelegt sind.|
|SQL_TIMEDATE_FUNCTIONS|1.0|Hinweis: der Informationstyp wurde in ODBC 1,0 eingeführt. jede Bitmaske ist mit der Version gekennzeichnet, in der Sie eingeführt wurde.<br/><br/>Eine SQLUINTEGER-Bitmaske, die die skalaren Datums-und Uhrzeit Funktionen auflistet, die vom Treiber und der zugehörigen Datenquelle unterstützt werden.<br/><br/>Die folgenden Bitmasken werden verwendet, um zu bestimmen, welche Datums-und Uhrzeit Funktionen unterstützt werden:<br/>SQL_FN_TD_CURRENT_DATE (ODBC 3,0)<br/>SQL_FN_TD_CURRENT_TIME (ODBC 3,0)<br/>SQL_FN_TD_CURRENT_TIMESTAMP (ODBC 3,0)<br/>SQL_FN_TD_CURDATE (ODBC 1,0)<br/>SQL_FN_TD_CURTIME (ODBC 1,0)<br/>SQL_FN_TD_DAYNAME (ODBC 2,0)<br/>SQL_FN_TD_DAYOFMONTH (ODBC 1,0)<br/>SQL_FN_TD_DAYOFWEEK (ODBC 1,0)<br/>SQL_FN_TD_DAYOFYEAR (ODBC 1,0)<br/>SQL_FN_TD_EXTRACT (ODBC 3,0)<br/>SQL_FN_TD_HOUR (ODBC 1,0)<br/>SQL_FN_TD_MINUTE (ODBC 1,0)<br/>SQL_FN_TD_MONTH (ODBC 1,0)<br/>SQL_FN_TD_MONTHNAME (ODBC 2,0)<br/>SQL_FN_TD_NOW (ODBC 1,0)<br/>SQL_FN_TD_QUARTER (ODBC 1,0)<br/>SQL_FN_TD_SECOND (ODBC 1,0)<br/>SQL_FN_TD_TIMESTAMPADD (ODBC 2,0)<br/>SQL_FN_TD_TIMESTAMPDIFF (ODBC 2,0)<br/>SQL_FN_TD_WEEK (ODBC 1,0)<br/>SQL_FN_TD_YEAR (ODBC 1,0)|
|SQL_TXN_CAPABLE|1.0|Hinweis: der Informationstyp wurde in ODBC 1,0 eingeführt. jeder Rückgabewert wird mit der Version bezeichnet, in der er eingeführt wurde.<br/><br/>Ein sqlusmallint-Wert, der die Transaktionsunterstützung im Treiber oder in der Datenquelle beschreibt:<br/>SQL_TC_NONE = Transaktionen werden nicht unterstützt. (ODBC 1,0)<br/>SQL_TC_DML = Transaktionen können nur DML-Anweisungen (Data Manipulation Language, Daten Bearbeitungs Sprache) enthalten (**Select**, **Insert**, **Update**, **Delete**). In einer Transaktion aufgetretene DDL-Anweisungen (Data Definition Language, Datendefinitionssprache) verursachen einen Fehler. (ODBC 1,0)<br/>SQL_TC_DDL_COMMIT = Transaktionen dürfen nur DML-Anweisungen enthalten. DDL-Anweisungen (**CREATE TABLE**, **Drop Index**usw.), die in einer Transaktion auftreten, bewirken, dass für die Transaktion ein Commit ausgeführt wird. (ODBC 2,0)<br/>SQL_TC_DDL_IGNORE = Transaktionen dürfen nur DML-Anweisungen enthalten. In einer Transaktion aufgetretene DDL-Anweisungen werden ignoriert. (ODBC 2,0)<br/>SQL_TC_ALL = Transaktionen können DDL-Anweisungen und DML-Anweisungen in beliebiger Reihenfolge enthalten. (ODBC 1,0)<br/><br/>(Da die Unterstützung von Transaktionen in SQL-92 obligatorisch ist, wird ein SQL-92-konformen Treiber [any Level] niemals SQL_TC_NONE zurückgegeben.)|
|SQL_TXN_ISOLATION_OPTION|1.0|Eine SQLUINTEGER-Bitmaske, die die Transaktions Isolations Stufen auflistet, die für den Treiber oder die Datenquelle verfügbar sind.<br/><br/>Die folgenden Bitmasken werden mit dem-Flag verwendet, um zu bestimmen, welche Optionen unterstützt werden:<br/>SQL_TXN_READ_UNCOMMITTED<br/>SQL_TXN_READ_COMMITTED<br/>SQL_TXN_REPEATABLE_READ<br/>SQL_TXN_SERIALIZABLE<br/><br/>Beschreibungen dieser Isolations Stufen finden Sie in der Beschreibung SQL_DEFAULT_TXN_ISOLATION.<br/><br/>Zum Festlegen der Transaktions Isolationsstufe Ruft eine Anwendung **SQLSetConnectAttr** auf, um das SQL_ATTR_TXN_ISOLATION-Attribut festzulegen. Weitere Informationen finden Sie unter [SQLSetConnectAttr-Funktion](sqlsetconnectattr-function.md).<br/><br/>Ein mit SQL-92 Entry Level-konformitäter Treiber gibt immer SQL_TXN_SERIALIZABLE zurück, wie er unterstützt wird. Ein mit der Anwendung für die Übergangs Ebene übergebender PPS gibt immer alle diese Optionen zurück, die unterstützt werden.|
|SQL_UNION|2.0|Eine SQLUINTEGER-Bitmaske, die die Unterstützung für die **Union** -Klausel aufzählt:<br/>SQL_U_UNION = die Datenquelle unterstützt die **Union** -Klausel.<br/>SQL_U_UNION_ALL = die Datenquelle unterstützt das **all** -Schlüsselwort in der **Union** -Klausel. (**SQLGetInfo** gibt in diesem Fall sowohl SQL_U_UNION als auch SQL_U_UNION_ALL zurück.)<br/><br/>Ein mit SQL-92 Entry Level-konformitäter Treiber gibt immer beide Optionen zurück, die unterstützt werden.|
|SQL_USER_NAME|1.0|Eine Zeichenfolge mit dem Namen, der in einer bestimmten Datenbank verwendet wird, der sich von dem Anmelde Namen unterscheiden kann.|
|SQL_XOPEN_CLI_YEAR|3.0|Eine Zeichenfolge, die das Jahr der Veröffentlichung der Open Group-Spezifikation angibt, mit der die Version des ODBC-Treiber-Managers vollständig konform ist.|
  
## <a name="example"></a>Beispiel  

 **SQLGetInfo** gibt Listen der unterstützten Optionen als SQLUINTEGER-Bitmaske in **infovalueptr*zurück. Die Bitmaske für jede Option wird in Verbindung mit dem-Flag verwendet, um zu bestimmen, ob die Option unterstützt wird.  
  
 Beispielsweise könnte eine Anwendung den folgenden Code verwenden, um zu bestimmen, ob die Skalarfunktion der Teil Zeichenfolge von dem Treiber unterstützt wird, der der Verbindung zugeordnet ist.  
  
 Ein weiteres Beispiel für die Verwendung von **SQLGetInfo**finden Sie unter [SQLTables-Funktion](sqltables-function.md).  
  
```cpp  
SQLUINTEGER fFuncs;  
  
SQLGetInfo(hdbc,  
           SQL_STRING_FUNCTIONS,  
           (SQLPOINTER)&fFuncs,  
           sizeof(fFuncs),  
           NULL);  
  
// SUBSTRING supported  
if (fFuncs & SQL_FN_STR_SUBSTRING)  
   ;   // do something  
  
// SUBSTRING not supported  
else  
   ;   // do something else  
```  
  
## <a name="related-functions"></a>Verwandte Funktionen  

 Zurückgeben der Einstellung eines Verbindungs Attributs  
 [SQLGetConnectAttr-Funktion](sqlgetconnectattr-function.md)  
  
 Bestimmen, ob ein Treiber eine Funktion unterstützt  
 [SQLGetFunctions-Funktion](sqlgetfunctions-function.md)  
  
 Zurückgeben der Einstellung eines Anweisungs Attributs  
 [SQLGetStmtAttr-Funktion](sqlgetstmtattr-function.md)  
  
 Zurückgeben von Informationen zu den Datentypen einer Datenquelle  
 [SQLGetTypeInfo-Funktion](sqlgettypeinfo-function.md)  
  
## <a name="see-also"></a>Weitere Informationen  

 [ODBC-API-Referenz](odbc-api-reference.md)  
 [ODBC-Headerdateien](../install/odbc-header-files.md)
