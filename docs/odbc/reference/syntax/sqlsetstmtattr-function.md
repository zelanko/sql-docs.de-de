---
title: SQLSetStmtAttr-Funktion | Microsoft-Dokumentation
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: MightyPen
ms.author: genemi
ms.openlocfilehash: 583639a5cd4680bf6cfcf03bbaf6ee9eb63adba8
ms.sourcegitcommit: b87d36c46b39af8b929ad94ec707dee8800950f5
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 02/08/2020
ms.locfileid: "68039650"
---
# <a name="sqlsetstmtattr-function"></a>SQLSetStmtAttr-Funktion
**Konformitäts**  
 Eingeführte Version: ODBC 3,0 Standards Compliance: ISO 92  
  
 **Zusammenfassung**  
 **SQLSetStmtAttr** legt Attribute im Zusammenhang mit einer-Anweisung fest.  
  
> [!NOTE]
>  Weitere Informationen dazu, wie der Treiber-Manager diese Funktion zuordnet, wenn eine ODBC *3. x* -Anwendung mit einem ODBC *2. x* -Treiber arbeitet, finden Sie unterzuordnen [von Ersetzungs Funktionen für die Abwärtskompatibilität von Anwendungen](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Syntax  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumente  
 *StatementHandle*  
 Der Anweisungs Handle.  
  
 *Attribut*  
 Der Die festzulegende Option, aufgelistet in "comments".  
  
 *ValuePtr*  
 Der Der-Wert, der dem- *Attribut*zugeordnet werden soll. Abhängig vom Wert des *Attributs*ist *ValuePtr* eine der folgenden:  
  
-   Ein ODBC-Deskriptorhandle.  
  
-   Ein SQLUINTEGER-Wert.  
  
-   Ein SQLULEN-Wert.  
  
-   Ein Zeiger auf einen der folgenden:  
  
    -   Eine NULL-terminierte Zeichenfolge.  
  
    -   Ein binärer Puffer.  
  
    -   Ein Wert oder ein Array vom Typ sqllen, SQLULEN oder sqlusmallint.  
  
    -   Ein Treiber definierter Wert.  
  
 Wenn das *Attribut* Argument ein Treiber spezifischer Wert ist, kann *ValuePtr* eine Ganzzahl mit Vorzeichen sein.  
  
 *StringLength*  
 Der Wenn *Attribute* ein ODBC-definiertes Attribut ist und *ValuePtr* auf eine Zeichenfolge oder einen binären Puffer zeigt, sollte dieses Argument der Länge von \* *ValuePtr*entsprechen. Wenn *Attribute* ein ODBC-definiertes Attribut und *ValuePtr* eine ganze Zahl ist, wird *StringLength* ignoriert.  
  
 Wenn *Attribute* ein Treiber definiertes Attribut ist, gibt die Anwendung die Art des Attributs für den Treiber-Manager an, indem das *StringLength* -Argument festgelegt wird. *StringLength* kann die folgenden Werte aufweisen:  
  
-   Wenn *ValuePtr* ein Zeiger auf eine Zeichenfolge ist, ist *StringLength* die Länge der Zeichenfolge oder SQL_NTS.  
  
-   Wenn *ValuePtr* ein Zeiger auf einen binären Puffer ist, platziert die Anwendung das Ergebnis des SQL_LEN_BINARY_ATTR (*length*)-Makros in *StringLength*. Dadurch wird ein negativer Wert in *StringLength*platziert.  
  
-   Wenn *ValuePtr* ein Zeiger auf einen anderen Wert als eine Zeichenfolge oder eine binäre Zeichenfolge ist, sollte *StringLength* den Wert SQL_IS_POINTER haben.  
  
-   Wenn *ValuePtr* einen Wert mit fester Länge enthält, ist *StringLength* entweder SQL_IS_INTEGER oder SQL_IS_UINTEGER.  
  
## <a name="returns"></a>Rückgabe  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR oder SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnose  
 Wenn **SQLSetStmtAttr** SQL_ERROR oder SQL_SUCCESS_WITH_INFO zurückgibt, kann ein zugeordneter SQLSTATE-Wert durch Aufrufen von **SQLGetDiagRec** mit dem *Handlertyp* SQL_HANDLE_STMT und einem *handle* von *StatementHandle*abgerufen werden. In der folgenden Tabelle werden die SQLSTATE-Werte aufgelistet, die häufig von **SQLSetStmtAttr** zurückgegeben werden, und die einzelnen Werte werden im Kontext dieser Funktion erläutert. die Notation "(DM)" geht vor den Beschreibungen von Sqlstates vor, die vom Treiber-Manager zurückgegeben werden. Der Rückgabecode, der den einzelnen SQLSTATE-Werten zugeordnet ist, ist SQL_ERROR, sofern nichts anderes angegeben ist.  
  
|SQLSTATE|Fehler|BESCHREIBUNG|  
|--------------|-----------|-----------------|  
|01000|Allgemeine Warnung|Treiber spezifische Informations Meldung. (Die Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|01s02 entsprechen|Optionswert geändert|Der Treiber hat den in *ValuePtr*angegebenen Wert nicht unterstützt, oder der in *ValuePtr* angegebene Wert war aufgrund von Implementierungs Arbeitsbedingungen ungültig, sodass der Treiber einen ähnlichen Wert ersetzt hat. (**SQLGetStmtAttr** kann aufgerufen werden, um den vorübergehend ersetzten Wert zu bestimmen.) Der Ersatzwert ist für " *StatementHandle* " gültig, bis der Cursor geschlossen wird. an diesem Punkt wird das Anweisungs Attribut auf seinen vorherigen Wert zurückgesetzt. Die Anweisungs Attribute, die geändert werden können, sind:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (Die Funktion gibt SQL_SUCCESS_WITH_INFO zurück.)|  
|08S01|Kommunikations Verbindungsfehler|Die Kommunikationsverbindung zwischen dem Treiber und der Datenquelle, mit der der Treiber verbunden war, ist fehlgeschlagen, bevor die Funktion die Verarbeitung abgeschlossen hat.|  
|24.000|Ungültiger Cursorstatus|Das *Attribut* war SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR oder SQL_ATTR_USE_BOOKMARKS, und der Cursor war geöffnet.|  
|HY000|Allgemeiner Fehler|Es ist ein Fehler aufgetreten, bei dem kein spezifischer SQLSTATE vorhanden war und für den kein Implementierungs spezifischer SQLSTATE definiert wurde. Die von **SQLGetDiagRec** im * \*MessageText* -Puffer zurückgegebene Fehlermeldung beschreibt den Fehler und die Ursache.|  
|HY001|Fehler bei der Speicher Belegung|Der Treiber konnte keinen Arbeitsspeicher zuweisen, der zur Unterstützung der Ausführung oder Beendigung der Funktion erforderlich ist.|  
|HY009|Ungültige Verwendung des NULL-Zeigers|Das *Attribut* Argument hat ein Anweisungs Attribut identifiziert, das ein Zeichen folgen Attribut erforderte, und das *ValuePtr* -Argument war ein NULL-Zeiger.|  
|HY010|Funktions Sequenz Fehler|(DM) eine asynchron ausgeführte Funktion wurde für das Verbindungs Handle aufgerufen, das mit dem *StatementHandle*verknüpft ist. Diese asynchrone Funktion wurde noch ausgeführt, als die **SQLSetStmtAttr** -Funktion aufgerufen wurde.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**oder **SQLMoreResults** wurde für das *StatementHandle* aufgerufen und SQL_PARAM_DATA_AVAILABLE zurückgegeben. Diese Funktion wurde aufgerufen, bevor Daten für alle gestreuten Parameter abgerufen wurden.<br /><br /> (DM) eine asynchron ausgeführte Funktion wurde für das *StatementHandle* aufgerufen und ausgeführt, als diese Funktion aufgerufen wurde.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**oder **SQLSetPos** wurde für das *StatementHandle* aufgerufen und SQL_NEED_DATA zurückgegeben. Diese Funktion wurde aufgerufen, bevor Daten für alle Data-at-Execution-Parameter oder-Spalten gesendet wurden.|  
|HY011|Das Attribut kann jetzt nicht festgelegt werden|Das *Attribut* wurde SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR oder SQL_ ATTR_USE_BOOKMARKS, und die Anweisung wurde vorbereitet.|  
|HY013|Speicher Verwaltungsfehler|Der Funktions Aufrufwert konnte nicht verarbeitet werden, da auf die zugrunde liegenden Speicher Objekte nicht zugegriffen werden konnte, möglicherweise aufgrund von wenig Arbeitsspeicher.|  
|HY017|Ungültige Verwendung eines automatisch zugeordneten Deskriptorhandles.|(DM) das *Attribut* Argument wurde SQL_ATTR_IMP_ROW_DESC oder SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) das Attribut Argument war SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC, und der Wert in *ValuePtr* war ein implizit *zugeordneter* Deskriptorhandle, das dem ursprünglich für die ARD-oder APD zugeordneten handle unterliegt.|  
|HY024|Ungültiger Attribut Wert|Bei Angabe des angegebenen *Attribut* Werts wurde in *ValuePtr*ein ungültiger Wert angegeben. (Der Treiber-Manager gibt diesen SQLSTATE nur für Verbindungs-und Anweisungs Attribute zurück, die einen diskreten Satz von Werten akzeptieren, z. b. SQL_ATTR_ACCESS_MODE oder SQL_ ATTR_ASYNC_ENABLE. Für alle anderen Verbindungs-und Anweisungs Attribute muss der Treiber den in *ValuePtr*angegebenen Wert überprüfen.)<br /><br /> Das Attribut Argument war SQL_ATTR_APP_ROW_DESC oder SQL_ATTR_APP_PARAM_DESC, und *ValuePtr* war ein explizit *zugeordneter* Deskriptorhandle, das sich nicht auf derselben Verbindung wie das *StatementHandle* -Argument befindet.|  
|HY090|Ungültige Zeichen folgen-oder Pufferlänge|(DM) * \*ValuePtr* ist eine Zeichenfolge, und das *StringLength* -Argument war kleiner als 0 (null), war aber nicht SQL_NTS.|  
|HY092|Ungültiger Attribut/Options Bezeichner|(DM) der für das Argument *Attribut* angegebene Wert war für die vom Treiber unterstützte ODBC-Version ungültig.<br /><br /> (DM) der für das Argument *Attribut* angegebene Wert war ein Schreib geschütztes Attribut.|  
|HY117|Die Verbindung wurde aufgrund eines unbekannten Transaktions Zustands angehalten. Nur Disconnect-und Read-Only-Funktionen sind zulässig.|(DM) Weitere Informationen zum angehaltenen Status finden Sie unter [SQLEndTran Function](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Optionales Feature nicht implementiert|Der für das Argument- *Attribut* angegebene Wert war ein gültiges ODBC-Anweisungs Attribut für die Version von ODBC, die vom Treiber unterstützt, jedoch nicht vom Treiber unterstützt wurde.<br /><br /> Das *Attribut* Argument wurde SQL_ATTR_ASYNC_ENABLE, und ein **SQLGetInfo-Befehl** mit einem *InfoType* von SQL_ASYNC_MODE gibt SQL_AM_CONNECTION zurück.<br /><br /> Das *Attribut* Argument wurde SQL_ATTR_ENABLE_AUTO_IPD, und der Wert des Connection-Attributs SQL_ATTR_AUTO_IPD SQL_FALSE.|  
|HYT01|Verbindungs Timeout abgelaufen|Der Verbindungs Timeout Zeitraum ist abgelaufen, bevor die Datenquelle auf die Anforderung geantwortet hat. Der Timeout Zeitraum für die Verbindung wird über **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT festgelegt.|  
|IM001|Der Treiber unterstützt diese Funktion nicht.|(DM) der dem *StatementHandle* zugeordnete Treiber unterstützt die-Funktion nicht.|  
|S1118|Der Treiber unterstützt keine asynchrone Benachrichtigung.|Beim Aufrufen von **SQLSetStmtAttr** zum Festlegen von SQL_ATTR_ASYNC_STMT_EVENT; asynchrone Benachrichtigungen werden vom Treiber nicht unterstützt.|  
  
## <a name="comments"></a>Kommentare  
 Anweisungs Attribute für eine-Anweisung bleiben in Kraft, bis Sie durch einen anderen Aufruf von **SQLSetStmtAttr** geändert werden oder bis die Anweisung durch Aufrufen von **SQLFreeHandle**gelöscht wird. Durch das Aufrufen von **SQLFreeStmt** mit der Option SQL_CLOSE, SQL_UNBIND oder SQL_RESET_PARAMS werden Anweisungs Attribute nicht zurückgesetzt.  
  
 Einige Anweisungs Attribute unterstützen die Ersetzung eines ähnlichen Werts, wenn die Datenquelle den in *ValuePtr*angegebenen Wert nicht unterstützt. In solchen Fällen gibt der Treiber SQL_SUCCESS_WITH_INFO und SQLSTATE 01s02 (Optionswert geändert) zurück. Wenn das *Attribut* beispielsweise SQL_ATTR_CONCURRENCY und *ValuePtr* SQL_CONCUR_ROWVER ist und die Datenquelle dies nicht unterstützt, ersetzt der Treiber SQL_CONCUR_VALUES und gibt SQL_SUCCESS_WITH_INFO zurück. Um den ersetzten Wert zu bestimmen, ruft eine Anwendung **SQLGetStmtAttr**auf.  
  
 Das Format der Informationen, die mit *ValuePtr* festgelegt sind, hängt vom angegebenen *Attribut*ab. **SQLSetStmtAttr** akzeptiert Attributinformationen in einem von zwei verschiedenen Formaten: einer Zeichenfolge oder einem ganzzahligen Wert. Das Format der einzelnen wird in der Beschreibung des Attributs angegeben. Dieses Format gilt für die Informationen, die für jedes Attribut in **SQLGetStmtAttr**zurückgegeben werden. Zeichen folgen, auf die vom *ValuePtr* -Argument von **SQLSetStmtAttr** verwiesen wird, haben eine Länge von *StringLength*.  
  
> [!NOTE]
>  Die Möglichkeit, Anweisungs Attribute auf Verbindungs Ebene durch Aufrufen von **SQLSetConnectAttr** festzulegen, wurde in ODBC *3. x*als veraltet markiert. ODBC *3. x* -Anwendungen sollten nie Anweisungs Attribute auf Verbindungs Ebene festlegen. ODBC *3. x* -Anweisungs Attribute können nicht auf Verbindungs Ebene festgelegt werden, mit Ausnahme der Attribute "SQL_ATTR_METADATA_ID" und "SQL_ATTR_ASYNC_ENABLE", bei denen es sich um Verbindungs Attribute und Anweisungs Attribute handelt und die entweder auf der Verbindungs Ebene oder auf der Anweisungs Ebene festgelegt werden können.  
> 
> [!NOTE]
>  ODBC *3. x* -Treiber müssen diese Funktionalität nur unterstützen, wenn Sie mit ODBC *2. x* -Anwendungen arbeiten sollten, die ODBC *2. x* -Anweisungs Optionen auf Verbindungs Ebene festlegen. Weitere Informationen finden Sie unter "Festlegen von Anweisungs Optionen auf der Verbindungs Ebene" unter [SQLSetConnectOption-Zuordnung](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) in Anhang G: Treiber Richtlinien zur Abwärtskompatibilität.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Anweisungs Attribute, die Deskriptorfelder festlegen  
 Viele Anweisungs Attribute entsprechen einem Header Feld eines Deskriptors. Das Festlegen dieser Attribute führt tatsächlich zur Einstellung der Deskriptorfelder. Das Festlegen von Feldern durch einen Befehl von **SQLSetStmtAttr** anstelle von **SQLSetDescField** hat den Vorteil, dass ein Deskriptorhandle für den Funktions aufrufnicht abgerufen werden muss.  
  
> [!CAUTION]  
>  Das Aufrufen von **SQLSetStmtAttr** für eine Anweisung kann sich auf andere-Anweisungen auswirken. Dies tritt auf, wenn die der Anweisung zugeordnete APD oder der ARD explizit zugeordnet und auch anderen-Anweisungen zugeordnet werden. Da **SQLSetStmtAttr** APD oder ARD ändert, gelten die Änderungen für alle-Anweisungen, denen dieser Deskriptor zugeordnet ist. Wenn dies nicht das erforderliche Verhalten ist, muss die Anwendung diesen Deskriptor von den anderen Anweisungen trennen (durch Aufrufen von **SQLSetStmtAttr** , um das Feld "SQL_ATTR_APP_ROW_DESC" oder "SQL_ATTR_APP_PARAM_DESC" auf ein anderes Deskriptorhandle festzulegen), bevor **SQLSetStmtAttr** erneut aufgerufen wird.  
  
 Wenn ein Deskriptorfeld als Ergebnis des festgelegten Anweisungs Attributs festgelegt wird, wird das Feld nur für die anwendbaren Deskriptoren festgelegt, die derzeit der durch das *StatementHandle* -Argument identifizierten Anweisung zugeordnet sind, und die Attribut Einstellung wirkt sich nicht auf Deskriptoren aus, die in der Zukunft mit dieser Anweisung verknüpft werden können. Wenn ein Deskriptorfeld, das auch ein Anweisungs Attribut ist, durch einen-Befehl von **SQLSetDescField**festgelegt wird, wird das entsprechende-Anweisungs Attribut festgelegt. Wenn ein explizit zugeordneter Deskriptor von einer-Anweisung getrennt wird, wird ein Anweisungs Attribut, das einem Header Feld entspricht, auf den Wert des Felds im implizit zugewiesenen Deskriptor zurückgesetzt.  
  
 Wenn eine-Anweisung zugeordnet wird (siehe [sqlzuzuordchandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), werden vier Deskriptorhandles automatisch zugeordnet und der Anweisung zugeordnet. Explizit zugeordnete Deskriptorhandles können mit der Anweisung verknüpft werden, indem **SQLAllocHandle** mit einem *ftortype* von SQL_HANDLE_DESC aufgerufen wird, um ein Deskriptorhandle zuzuordnen, und dann **SQLSetStmtAttr** aufgerufen wird, um das Deskriptorhandle der Anweisung zuzuordnen.  
  
 Die Anweisungs Attribute in der folgenden Tabelle entsprechen den deskriptorheaderfeldern.  
  
|Statement-Attribut|Header Feld|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|Mäuse|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|Mäuse|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|Mäuse|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|Mäuse|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Anweisungsattribute  
 Die derzeit definierten Attribute und die Version von ODBC, in der Sie eingeführt wurden, sind in der folgenden Tabelle aufgeführt: Es wird erwartet, dass mehr Attribute von Treibern definiert werden, um unterschiedliche Datenquellen zu nutzen. Ein Bereich von Attributen wird von ODBC reserviert. Treiber Entwickler müssen Werte für Ihre eigene Treiber spezifische Verwendung in der geöffneten Gruppe reservieren. Weitere Informationen finden Sie unter [Treiber spezifische Datentypen, deskriptortypen, Informationstypen, Diagnose Typen und Attribute](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|attribute|*ValuePtr* -Inhalt|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3,0)|Das Handle für das APD für nachfolgende Aufrufe von **SQLExecute** und **SQLExecDirect** für das Anweisungs Handle. Der Anfangswert dieses Attributs ist der Deskriptor, der bei der anfänglichen Zuordnung der Anweisung implizit zugeordnet wurde. Wenn der Wert dieses Attributs auf SQL_NULL_DESC oder das Handle festgelegt ist, das ursprünglich für den Deskriptor zugewiesen wurde, wird ein explizit zugeordnetes APD-handle, das zuvor mit dem Anweisungs Handle verknüpft war, von ihm getrennt, und das Anweisungs Handle kehrt zum implizit zugewiesenes APD-handle.<br /><br /> Dieses Attribut kann nicht auf ein Deskriptorhandle festgelegt werden, das implizit für eine andere Anweisung oder einem anderen Deskriptorhandle zugeordnet wurde, das implizit für dieselbe Anweisung festgelegt wurde. implizit zugeordnete Deskriptorhandles können nicht mehr als einer Anweisung oder einem Deskriptorhandle zugeordnet werden.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3,0)|Das Handle für die ARD für nachfolgende Abruf Vorgänge für das Anweisungs Handle. Der Anfangswert dieses Attributs ist der Deskriptor, der bei der anfänglichen Zuordnung der Anweisung implizit zugeordnet wurde. Wenn der Wert dieses Attributs auf SQL_NULL_DESC oder das Handle festgelegt ist, das ursprünglich für den Deskriptor zugewiesen wurde, wird ein explizit zugeordnetes ARD-handle, das zuvor dem Anweisungs Handle zugeordnet war, von ihm getrennt, und das Anweisungs Handle kehrt zum implizit zugeordneter ARD-handle.<br /><br /> Dieses Attribut kann nicht auf ein Deskriptorhandle festgelegt werden, das implizit für eine andere Anweisung oder einem anderen Deskriptorhandle zugeordnet wurde, das implizit für dieselbe Anweisung festgelegt wurde. implizit zugeordnete Deskriptorhandles können nicht mehr als einer Anweisung oder einem Deskriptorhandle zugeordnet werden.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1,0)|Ein SQLULEN-Wert, der angibt, ob eine mit der angegebenen-Anweisung aufgerufene Funktion asynchron ausgeführt wird:<br /><br /> SQL_ASYNC_ENABLE_OFF = asynchrone Ausführungs Unterstützung auf Anweisungs Ebene deaktivieren (Standard).<br /><br /> SQL_ASYNC_ENABLE_ON = asynchrone Ausführungs Unterstützung auf Anweisungs Ebene aktivieren.<br /><br /> Weitere Informationen finden Sie unter [asynchrone Ausführung (Abruf Methode)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Für Treiber mit asynchroner Ausführungs Unterstützung auf Anweisungs Ebene ist das Anweisungs Attribut SQL_ATTR_ASYNC_ENABLE schreibgeschützt. Der Wert ist identisch mit dem Wert des Attributs auf Verbindungs Ebene mit dem gleichen Namen zum Zeitpunkt der Zuordnung des Anweisungs Handles.<br /><br /> Aufrufen von **SQLSetStmtAttr** , um SQL_ATTR_ASYNC_ENABLE festzulegen, wenn der SQL_ASYNC_MODE *InfoType* zurückgibt SQL_AM_CONNECTION gibt SQLSTATE HYC00 (optionales Feature nicht implementiert) zurück. Weitere Informationen finden Sie unter [SQLSetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) .|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3,8)|Ein SQLPOINTER-Wert, der ein Ereignis Handle ist.<br /><br /> Die Benachrichtigung über den Abschluss asynchroner Funktionen wird durch Aufrufen von **SQLSetStmtAttr** aktiviert, um das **SQL_ATTR_ASYNC_STMT_EVENT** -Attribut festzulegen und das Ereignis handle anzugeben.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3,8)|Ein SQLPOINTER-Zeiger auf die asynchrone Rückruffunktion.<br /><br /> Nur der Treiber-Manager kann die **SQLSetStmtAttr** -Funktion eines Treibers mit diesem Attribut aufrufen.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3,8)|Ein SQLPOINTER zur Kontext Struktur.<br /><br /> Nur der Treiber-Manager kann die **SQLSetStmtAttr** -Funktion eines Treibers mit diesem Attribut aufrufen.|  
|SQL_ATTR_CONCURRENCY (ODBC 2,0)|Ein SQLULEN-Wert, der die Cursor Parallelität angibt:<br /><br /> SQL_CONCUR_READ_ONLY = Cursor ist schreibgeschützt. Es sind keine Updates zulässig.<br /><br /> SQL_CONCUR_LOCK = Cursor verwendet die niedrigste Sperr Ebene, um sicherzustellen, dass die Zeile aktualisiert werden kann.<br /><br /> SQL_CONCUR_ROWVER = Cursor verwendet die Steuerung der vollständigen Parallelität und vergleicht Zeilen Versionen wie SQLBase ROWID oder Sybase-Zeitstempel.<br /><br /> SQL_CONCUR_VALUES = Cursor verwendet die Steuerung der vollständigen Parallelität, wobei Werte verglichen werden.<br /><br /> Der Standardwert für SQL_ATTR_CONCURRENCY ist SQL_CONCUR_READ_ONLY.<br /><br /> Dieses Attribut kann für einen geöffneten Cursor nicht angegeben werden. Weitere Informationen finden Sie unter Parallelitäts [Typen](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Wenn das SQL_ATTR_CURSOR_TYPE- *Attribut* in einen Typ geändert wird, der den aktuellen Wert von SQL_ATTR_CONCURRENCY nicht unterstützt, wird der Wert von SQL_ATTR_CONCURRENCY zur Ausführungszeit geändert, und es wird eine Warnung ausgegeben, wenn **SQLExecDirect** oder **SQLPrepare** aufgerufen wird.<br /><br /> Wenn der Treiber die **Select for Update** -Anweisung unterstützt und eine solche Anweisung ausgeführt wird, während der Wert von SQL_ATTR_CONCURRENCY auf SQL_CONCUR_READ_ONLY festgelegt ist, wird ein Fehler zurückgegeben. Wenn der Wert von SQL_ATTR_CONCURRENCY in einen Wert geändert wird, den der Treiber für einen Wert von SQL_ATTR_CURSOR_TYPE, aber nicht für den aktuellen Wert von SQL_ATTR_CURSOR_TYPE unterstützt, wird der Wert von SQL_ATTR_CURSOR_TYPE zur Ausführungszeit geändert, und SQLSTATE 01s02 (Optionswert geändert) wird ausgegeben, wenn **SQLExecDirect** oder **SQLPrepare** aufgerufen wird.<br /><br /> Wenn die angegebene Parallelität von der Datenquelle nicht unterstützt wird, ersetzt der Treiber eine andere Parallelität und gibt SQLSTATE 01s02 (Optionswert geändert) zurück. Bei SQL_CONCUR_VALUES ersetzt der Treiber SQL_CONCUR_ROWVER und umgekehrt. Bei SQL_CONCUR_LOCK ersetzt der Treiber in der richtigen Reihenfolge SQL_CONCUR_ROWVER oder SQL_CONCUR_VALUES. Die Gültigkeit des ersetzenden Werts wird nicht bis zur Ausführungszeit überprüft.<br /><br /> Weitere Informationen über die Beziehung zwischen SQL_ATTR_CONCURRENCY und den anderen Cursor Attributen finden Sie unter [Cursor Merkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3,0)|Ein SQLULEN-Wert, der die Unterstützungs Ebene angibt, die für die Anwendung erforderlich ist. Das Festlegen dieses Attributs wirkt sich auf nachfolgende Aufrufe von **SQLExecDirect** und **SQLExecute**aus.<br /><br /> SQL_NONSCROLLABLE = scrollbare Cursor sind im Anweisungs Handle nicht erforderlich. Wenn die Anwendung **SQLFetchScroll** für dieses Handle aufruft, ist der einzige gültige Wert von *FetchOrientation* SQL_FETCH_NEXT. Dies ist die Standardoption.<br /><br /> SQL_SCROLLABLE = scrollbare Cursor sind für das Anweisungs Handle erforderlich. Beim Aufrufen von **SQLFetchScroll**kann die Anwendung einen beliebigen gültigen Wert von *FetchOrientation*angeben, wodurch die Cursor Positionierung in anderen Modi als im sequenziellen Modus erreicht wird.<br /><br /> Weitere Informationen zu scrollfähigen Cursorn finden Sie unter [scrollfähige Cursor](../../../odbc/reference/develop-app/scrollable-cursors.md). Weitere Informationen über die Beziehung zwischen SQL_ATTR_CURSOR_SCROLLABLE und den anderen Cursor Attributen finden Sie unter [Cursor Merkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md) .|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3,0)|Ein SQLULEN-Wert, der angibt, ob Cursor im Anweisungs Handle die an einem Resultset durch einen anderen Cursor vorgenommenen Änderungen sichtbar machen. Das Festlegen dieses Attributs wirkt sich auf nachfolgende Aufrufe von **SQLExecDirect** und **SQLExecute**aus. Eine Anwendung kann den Wert dieses Attributs zurück lesen, um den ursprünglichen Zustand oder seinen Zustand zu erhalten, der von der Anwendung zuletzt festgelegt wurde.<br /><br /> SQL_UNSPECIFIED = es ist nicht angegeben, was der Cursortyp ist und ob Cursor im Anweisungs Handle die Änderungen sichtbar machen, die an einem Resultset durch einen anderen Cursor vorgenommen werden. Cursor im Anweisungs Handle können sichtbar machen, dass keine, einige oder alle Änderungen sichtbar sind. Dies ist die Standardoption.<br /><br /> SQL_INSENSITIVE = alle Cursor im Anweisungs Handle zeigen das Resultset an, ohne dass von einem anderen Cursor vorgenommene Änderungen reflektiert werden. Unempfindliche Cursor sind schreibgeschützt. Dies entspricht einem statischen Cursor, der über eine schreibgeschützte Parallelität verfügt.<br /><br /> SQL_SENSITIVE = alle Cursor im Anweisungs Handle machen sichtbar, dass alle Änderungen, die von einem anderen Cursor an einem Resultset vorgenommen werden.<br /><br /> Weitere Informationen über die Beziehung zwischen SQL_ATTR_CURSOR_SENSITIVITY und den anderen Cursor Attributen finden Sie unter [Cursor Merkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2,0)|Ein SQLULEN-Wert, der den Cursortyp angibt:<br /><br /> SQL_CURSOR_FORWARD_ONLY = der Cursor führt einen Bildlauf nach oben aus.<br /><br /> SQL_CURSOR_STATIC = die Daten im Resultset sind statisch.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = der Treiber speichert und verwendet die Schlüssel für die Anzahl der Zeilen, die im SQL_ATTR_KEYSET_SIZE Statement-Attribut angegeben sind.<br /><br /> SQL_CURSOR_DYNAMIC = der Treiber speichert und verwendet nur die Schlüssel für die Zeilen im Rowset.<br /><br /> Der Standardwert ist SQL_CURSOR_FORWARD_ONLY. Dieses Attribut kann nicht angegeben werden, nachdem die SQL-Anweisung vorbereitet wurde.<br /><br /> Wenn der angegebene Cursortyp von der Datenquelle nicht unterstützt wird, ersetzt der Treiber einen anderen Cursortyp und gibt SQLSTATE 01s02 (Optionswert geändert) zurück. Bei einem gemischten oder dynamischen Cursor ersetzt der Treiber einen keysetgesteuerten oder statischen Cursor in der richtigen Reihenfolge. Bei einem keysetgesteuerten Cursor ersetzt der Treiber einen statischen Cursor.<br /><br /> Weitere Informationen zu scrollbaren Cursor Typen finden Sie unter [scrollbare Cursor Typen](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Weitere Informationen über die Beziehung zwischen SQL_ATTR_CURSOR_TYPE und den anderen Cursor Attributen finden Sie unter [Cursor Merkmale und Cursortyp](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3,0)|Ein SQLULEN-Wert, der angibt, ob die automatische Auffüllung der IPD ausgeführt wird:<br /><br /> SQL_TRUE = schaltet die automatische Auffüllung der IPD nach einem **SQLPrepare**-Auffüllung. SQL_FALSE = deaktiviert die automatische Auffüllung der IPD nach einem **SQLPrepare**-Befehl. (Eine Anwendung kann weiterhin IPD-Feldinformationen abrufen, indem **SQLDescribeParam**aufgerufen wird, sofern dies unterstützt wird.) Der Standardwert des Anweisungs Attributs SQL_ATTR_ENABLE_AUTO_IPD ist SQL_FALSE. Weitere Informationen finden Sie unter automatische Auffüllung der [IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3,0)|Eine sqllen \* , die auf einen binären Lesezeichen Wert zeigt. Wenn **SQLFetchScroll** mit *ffetchorientation* gleich SQL_FETCH_BOOKMARK aufgerufen wird, übernimmt der Treiber den Lesezeichen Wert aus diesem Feld. Dieses Feld ist standardmäßig ein NULL-Zeiger. Weitere Informationen finden Sie unter [Scrollen nach Lesezeichen](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> Der Wert, auf den dieses Feld verweist, wird nicht zum Löschen durch Lesezeichen, zum Aktualisieren durch Lesezeichen oder zum Abrufen von Lesezeichen Vorgängen in **SQLBulkOperations**verwendet, die in rowsetpuffern zwischengespeicherte Lesezeichen verwenden.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3,0)|Das Handle für die IPD. Der Wert dieses Attributs ist der Deskriptor, der bei der anfänglichen Zuordnung der Anweisung zugeordnet wurde. Das Attribut kann von der Anwendung nicht festgelegt werden.<br /><br /> Dieses Attribut kann durch einen Aufrufen von **SQLGetStmtAttr** abgerufen, aber nicht durch einen-Befehl von **SQLSetStmtAttr**festgelegt werden.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3,0)|Das Handle für den IRD. Der Wert dieses Attributs ist der Deskriptor, der bei der anfänglichen Zuordnung der Anweisung zugeordnet wurde. Das Attribut kann von der Anwendung nicht festgelegt werden.<br /><br /> Dieses Attribut kann durch einen Aufrufen von **SQLGetStmtAttr** abgerufen, aber nicht durch einen-Befehl von **SQLSetStmtAttr**festgelegt werden.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2,0)|Ein SQLULEN-Wert, der die Anzahl der Zeilen im Keyset eines keysetgesteuerten Cursors angibt. Wenn die Keysetgröße den Wert 0 (Standard) hat, ist der Cursor vollständig keysetgesteuert. Wenn die Keysetgröße größer als 0 ist, wird der Cursor gemischt (keysetgesteuert innerhalb des Keysets und dynamisch außerhalb des Keysets). Die standardkeysetgröße ist 0 (null). Weitere Informationen zu keysetgesteuerten Cursorn finden Sie unter [keysetgesteuerte Cursor](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Wenn die angegebene Größe die maximale Keysetgröße überschreitet, ersetzt der Treiber diese Größe und gibt SQLSTATE 01s02 (Optionswert geändert) zurück.<br /><br /> **SQLFetch** oder **SQLFetchScroll** gibt einen Fehler zurück, wenn die Keysetgröße größer als 0 und kleiner als die Rowsetgröße ist.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1,0)|Ein SQLULEN-Wert, der die maximale Datenmenge angibt, die der Treiber aus einer Zeichen-oder Binär Spalte zurückgibt. Wenn *ValuePtr* kleiner als die Länge der verfügbaren Daten ist, werden die Daten von **SQLFetch** oder **SQLGetData** abgeschnitten, und es wird SQL_SUCCESS zurückgegeben. Wenn *ValuePtr* den Wert 0 (Standard) hat, versucht der Treiber, alle verfügbaren Daten zurückzugeben.<br /><br /> Wenn die angegebene Länge kleiner ist als die minimale Datenmenge, die von der Datenquelle zurückgegeben werden kann oder die die maximale Datenmenge überschreitet, die von der Datenquelle zurückgegeben werden kann, ersetzt der Treiber diesen Wert und gibt SQLSTATE 01s02 (Optionswert geändert) zurück.<br /><br /> Der Wert dieses Attributs kann für einen geöffneten Cursor festgelegt werden. die Einstellung wird jedoch möglicherweise nicht sofort wirksam. in diesem Fall gibt der Treiber SQLSTATE 01s02 (Optionswert geändert) zurück und setzt das Attribut auf seinen ursprünglichen Wert zurück.<br /><br /> Dieses Attribut dient zum Reduzieren des Netzwerk Datenverkehrs und sollte nur unterstützt werden, wenn die Datenquelle (im Gegensatz zum Treiber) in einem Treiber mit mehreren Ebenen implementiert werden kann. Dieser Mechanismus sollte nicht von Anwendungen zum Abschneiden von Daten verwendet werden. um empfangene Daten zu kürzen, sollte eine Anwendung die maximale Pufferlänge im *BufferLength* -Argument in **SQLBindCol** oder **SQLGetData**angeben.|  
|SQL_ATTR_MAX_ROWS (ODBC 1,0)|Ein SQLULEN-Wert, der der maximalen Anzahl von Zeilen entspricht, die für eine **Select** -Anweisung an die Anwendung zurückgegeben werden sollen. Wenn \* *ValuePtr* den Wert 0 (Standard) hat, gibt der Treiber alle Zeilen zurück.<br /><br /> Mit diesem Attribut wird der Netzwerkverkehr reduziert. Konzeptionell wird Sie angewendet, wenn das Resultset erstellt wird, und beschränkt das Resultset auf die ersten *ValuePtr* -Zeilen. Wenn die Anzahl der Zeilen im Resultset größer als *ValuePtr*ist, wird das Resultset abgeschnitten.<br /><br /> SQL_ATTR_MAX_ROWS gilt für alle Resultsets in der *Anweisung*, einschließlich derjenigen, die von Katalog Funktionen zurückgegeben werden. SQL_ATTR_MAX_ROWS legt einen maximalen Wert für den Wert der Cursor Zeilen Anzahl fest.<br /><br /> Ein Treiber sollte SQL_ATTR_MAX_ROWS Verhalten für **SQLFetch** oder **SQLFetchScroll** nicht emulieren (wenn die Größenbeschränkungen für Resultsets nicht in der Datenquelle implementiert werden können), wenn nicht gewährleistet werden kann, dass SQL_ATTR_MAX_ROWS ordnungsgemäß implementiert wird.<br /><br /> Es ist Treiber definiert, ob SQL_ATTR_MAX_ROWS auf andere Anweisungen als SELECT-Anweisungen (z. b. Katalog Funktionen) angewendet wird.<br /><br /> Der Wert dieses Attributs kann für einen geöffneten Cursor festgelegt werden. die Einstellung wird jedoch möglicherweise nicht sofort wirksam. in diesem Fall gibt der Treiber SQLSTATE 01s02 (Optionswert geändert) zurück und setzt das Attribut auf seinen ursprünglichen Wert zurück.|  
|SQL_ATTR_METADATA_ID (ODBC 3,0)|Ein SQLULEN-Wert, der bestimmt, wie die Zeichen folgen Argumente von Katalog Funktionen behandelt werden.<br /><br /> Wenn SQL_TRUE, wird das Zeichen folgen Argument der Katalog Funktionen als Bezeichner behandelt. Die Groß-/Kleinschreibung ist nicht signifikant. Bei nicht durch Trennzeichen getrennten Zeichen folgen entfernt der Treiber alle nachfolgenden Leerzeichen, und die Zeichenfolge wird in Großbuchstaben gefaltet. Beim durch Trennzeichen getrennten Zeichen folgen entfernt der Treiber alle führenden oder nachfolgenden Leerzeichen und nimmt die gleichen zwischen den Trennzeichen auf. Wenn eines der Argumente auf einen NULL-Zeiger festgelegt ist, gibt die Funktion SQL_ERROR und SQLSTATE HY009 zurück (Ungültige Verwendung des NULL-Zeigers).<br /><br /> Wenn SQL_FALSE, werden die Zeichen folgen Argumente von Katalog Funktionen nicht als Bezeichner behandelt. Der Fall ist wichtig. Abhängig vom-Argument können Sie entweder ein Muster für die Zeichen folgen Suche oder nicht enthalten.<br /><br /> Der Standardwert ist SQL_FALSE.<br /><br /> Das *TABLETYPE* -Argument von **SQLTables**, das eine Liste von Werten annimmt, ist von diesem Attribut nicht betroffen.<br /><br /> SQL_ATTR_METADATA_ID können auch auf der Verbindungs Ebene festgelegt werden. (Es und SQL_ATTR_ASYNC_ENABLE sind die einzigen Anweisungs Attribute, die auch Verbindungs Attribute sind.)<br /><br /> Weitere Informationen finden Sie unter [Argumente in Katalog Funktionen](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1,0)|Ein SQLULEN-Wert, der angibt, ob der Treiber SQL-Zeichen folgen für Escapesequenzen scannen soll:<br /><br /> SQL_NOSCAN_OFF = der Treiber scannt SQL-Zeichen folgen nach Escapesequenzen (Standardeinstellung).<br /><br /> SQL_NOSCAN_ON = der Treiber scannt keine SQL-Zeichen folgen für Escapesequenzen. Stattdessen sendet der Treiber die Anweisung direkt an die Datenquelle.<br /><br /> Weitere Informationen finden Sie unter Escapesequenzen [in ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3,0)|Ein SQLULEN *-Wert, der auf einen Offset zeigt, der Zeiger auf das Ändern der Bindung von dynamischen Parametern hinzugefügt wird. Wenn dieses Feld ungleich NULL ist, dereferenziert der Treiber den Zeiger, fügt den dereferenzierten Wert jedem der zurück gestellten Felder im Deskriptordatensatz (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR) hinzu und verwendet die neuen Zeiger Werte. beim Binden. Standardmäßig ist der Wert auf NULL festgelegt.<br /><br /> Der Bindungs Offset wird immer direkt den Feldern SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR hinzugefügt. Wenn der Offset in einen anderen Wert geändert wird, wird der neue Wert dem Wert im Deskriptorfeld weiterhin direkt hinzugefügt. Der neue Offset wird dem Feldwert und allen früheren Offsets nicht hinzugefügt.<br /><br /> Weitere Informationen finden Sie unter [Parameter Bindungs Offsets](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_BIND_OFFSET_PTR Feld im APD-Header festgelegt.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3,0)|Ein SQLULEN-Wert, der die Bindungs Ausrichtung angibt, die für dynamische Parameter verwendet werden soll.<br /><br /> Dieses Feld ist auf SQL_PARAM_BIND_BY_COLUMN (Standardeinstellung) festgelegt, um die spaltenweise Bindung auszuwählen.<br /><br /> Um die zeilenweise Bindung auszuwählen, wird dieses Feld auf die Länge der Struktur oder auf eine Instanz eines Puffers festgelegt, die an einen Satz dynamischer Parameter gebunden wird. Diese Länge muss Leerzeichen für alle gebundenen Parameter und alle Auffüll Zeichen der Struktur oder des Puffers enthalten, um sicherzustellen, dass das Ergebnis, wenn die Adresse eines gebundenen Parameters mit der angegebenen Länge inkrementiert wird, auf den Anfang desselben Parameters in der nächsten Zeile zeigt. Parametersatz. Wenn der *sizeof* -Operator in ANSI C verwendet wird, ist dieses Verhalten garantiert.<br /><br /> Weitere Informationen finden Sie unter [Binden von Parameter Arrays](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_ BIND_TYPE Feld im APD-Header festgelegt.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3,0)|Ein sqlusmallint \* -Wert, der auf ein Array von sqlusmallint-Werten verweist, die verwendet werden, um einen Parameter während der Ausführung einer SQL-Anweisung zu ignorieren. Jeder Wert ist entweder auf SQL_PARAM_PROCEED (für den Parameter, der ausgeführt werden soll) oder SQL_PARAM_IGNORE (damit der Parameter ignoriert wird) festgelegt.<br /><br /> Ein Satz von Parametern kann während der Verarbeitung ignoriert werden, indem der Statuswert im Array festgelegt wird, auf den SQL_DESC_ARRAY_STATUS_PTR in der APD zeigt, um SQL_PARAM_IGNORE. Ein Satz von Parametern wird verarbeitet, wenn der Statuswert auf SQL_PARAM_PROCEED festgelegt ist oder wenn keine Elemente im Array festgelegt sind.<br /><br /> Dieses Anweisungs Attribut kann auf einen NULL-Zeiger festgelegt werden. in diesem Fall gibt der Treiber keine Parameter Statuswerte zurück. Dieses Attribut kann jederzeit festgelegt werden, aber der neue Wert wird erst verwendet, wenn **SQLExecDirect** oder **SQLExecute** das nächste Mal aufgerufen wird.<br /><br /> Dieses Attribut wird ignoriert, wenn kein gebundener Parameter vorhanden ist.<br /><br /> Weitere Informationen finden Sie unter [Verwenden von Parameter Arrays](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_ARRAY_STATUS_PTR Feld im APD-Header festgelegt.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3,0)|Ein sqlusmallint \* -Wert, der auf ein Array von sqlusmallint-Werten zeigt, die Statusinformationen für jede Zeile von Parameterwerten nach einem Aufrufen von **SQLExecute** oder **SQLExecDirect**enthalten. Dieses Feld ist nur erforderlich, wenn PARAMSET_SIZE größer als 1 ist.<br /><br /> Die Statuswerte können die folgenden Werte enthalten:<br /><br /> SQL_PARAM_SUCCESS: die SQL-Anweisung wurde für diesen Parametersatz erfolgreich ausgeführt.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: die SQL-Anweisung wurde für diesen Parametersatz erfolgreich ausgeführt. Warn Informationen sind jedoch in der Diagnosedaten Struktur verfügbar.<br /><br /> SQL_PARAM_ERROR: Fehler bei der Verarbeitung dieser Gruppe von Parametern. Zusätzliche Fehlerinformationen sind in der Diagnosedaten Struktur verfügbar.<br /><br /> SQL_PARAM_UNUSED: dieser Parametersatz wurde nicht verwendet, möglicherweise aufgrund der Tatsache, dass ein vorheriger Parametersatz einen Fehler verursacht hat, der die weitere Verarbeitung abgebrochen hat, oder weil SQL_PARAM_IGNORE für diesen Parametersatz in dem von SQL_ATTR_PARAM_ der angegebenen Array festgelegt wurde. OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: der Treiber behandelt Arrays von Parametern als monolithische Einheit und generiert daher nicht diese Ebene von Fehlerinformationen.<br /><br /> Dieses Anweisungs Attribut kann auf einen NULL-Zeiger festgelegt werden. in diesem Fall gibt der Treiber keine Parameter Statuswerte zurück. Dieses Attribut kann jederzeit festgelegt werden, aber der neue Wert wird erst verwendet, wenn **SQLExecute** oder **SQLExecDirect** aufgerufen wird. Beachten Sie, dass das Festlegen dieses Attributs das vom Treiber implementierte Ausgabeparameter Verhalten beeinflussen kann.<br /><br /> Weitere Informationen finden Sie unter [Verwenden von Parameter Arrays](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_ARRAY_STATUS_PTR Feld im IPD-Header festgelegt.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3,0)|Ein SQLULEN \* -Daten Satz Feld, das auf einen Puffer zeigt, in dem die Anzahl der verarbeiteten Parametersätze zurückgegeben werden soll, einschließlich der Fehler Sätze. Wenn dies ein NULL-Zeiger ist, wird keine Zahl zurückgegeben.<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_ROWS_PROCESSED_PTR Feld im IPD-Header festgelegt.<br /><br /> Wenn der **SQLExecDirect** -oder **SQLExecute** -Befehl, der den Puffer füllt, auf den dieses Attribut zeigt, keine SQL_SUCCESS oder SQL_SUCCESS_WITH_INFO zurückgibt, ist der Inhalt des Puffers nicht definiert.<br /><br /> Weitere Informationen finden Sie unter [Verwenden von Parameter Arrays](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3,0)|Ein SQLULEN-Wert, der die Anzahl der Werte für jeden Parameter angibt. Wenn SQL_ATTR_PARAMSET_SIZE größer als 1 ist, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR des APD-Punkts auf Arrays. Die Kardinalität jedes Arrays ist gleich dem Wert dieses Felds.<br /><br /> Dieses Attribut wird ignoriert, wenn kein gebundener Parameter vorhanden ist.<br /><br /> Weitere Informationen finden Sie unter [Verwenden von Parameter Arrays](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_ARRAY_SIZE Feld im APD-Header festgelegt.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1,0)|Ein SQLULEN-Wert, der der Anzahl der Sekunden entspricht, die auf die Ausführung einer SQL-Anweisung gewartet werden soll, bevor Sie zur Anwendung zurückkehrt. Wenn *ValuePtr* gleich 0 (Standard) ist, gibt es kein Timeout.<br /><br /> Wenn das angegebene Timeout den maximalen Timeout Wert in der Datenquelle überschreitet oder kleiner ist als das minimale Timeout, ersetzt **SQLSetStmtAttr** diesen Wert und gibt SQLSTATE 01s02 (Optionswert geändert) zurück.<br /><br /> Beachten Sie, dass die Anwendung **SQLCloseCursor** nicht zum wieder verwenden der Anweisung verwenden muss, wenn bei einer **Select** -Anweisung ein Timeout aufgetreten ist.<br /><br /> Das in diesem Anweisungs Attribut festgelegte Abfrage Timeout ist sowohl im synchronen als auch im asynchronen Modus gültig.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2,0)|Ein SQLULEN-Wert:<br /><br /> SQL_RD_ON = **SQLFetchScroll** und ruft **SQLFetch** in ODBC *3. x*Daten ab, nachdem der Cursor an der angegebenen Position positioniert wurde. Dies ist die Standardoption.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** und in ODBC *3. x*rufen **SQLFetch** keine Daten ab, nachdem der Cursor positioniert wurde.<br /><br /> Wenn Sie SQL_RETRIEVE_DATA auf SQL_RD_OFF festlegen, kann eine Anwendung überprüfen, ob eine Zeile vorhanden ist, oder ein Lesezeichen für die Zeile abrufen, ohne den Aufwand für das Abrufen von Zeilen zu verursachen. Weitere Informationen finden Sie unter [scrollen und Abrufen von Zeilen](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> Der Wert dieses Attributs kann für einen geöffneten Cursor festgelegt werden. die Einstellung wird jedoch möglicherweise nicht sofort wirksam. in diesem Fall gibt der Treiber SQLSTATE 01s02 (Optionswert geändert) zurück und setzt das Attribut auf seinen ursprünglichen Wert zurück.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3,0)|Ein SQLULEN-Wert, der die Anzahl der Zeilen angibt, die von jedem **SQLFetch** -oder **SQLFetchScroll**-Befehl zurückgegeben werden. Dabei handelt es sich auch um die Anzahl der Zeilen in einem Lesezeichen Array, die in einem Massen Lesezeichen-Vorgang in **SQLBulkOperations**verwendet werden. Der Standardwert ist 1.<br /><br /> Wenn die angegebene Rowsetgröße die maximale Rowsetgröße überschreitet, die von der Datenquelle unterstützt wird, ersetzt der Treiber diesen Wert und gibt SQLSTATE 01s02 (Optionswert geändert) zurück.<br /><br /> Weitere Informationen finden Sie unter [Rowsetgröße](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_ARRAY_SIZE Feld im ARD-Header festgelegt.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3,0)|Ein SQLULEN *-Wert, der auf einen Offset zeigt, der Zeiger zum Ändern der Bindung von Spaltendaten hinzugefügt wird. Wenn dieses Feld ungleich NULL ist, dereferenziert der Treiber den Zeiger, fügt den dereferenzierten Wert jedem der zurück gestellten Felder im Deskriptordatensatz (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR und SQL_DESC_OCTET_LENGTH_PTR) hinzu und verwendet die neuen Zeiger Werte. beim Binden. Standardmäßig ist der Wert auf NULL festgelegt.<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_BIND_OFFSET_PTR Feld im ARD-Header festgelegt.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1,0)|Ein SQLULEN-Wert, der die zu verwendende Bindungs Ausrichtung festlegt, wenn **SQLFetch** oder **SQLFetchScroll** in der zugeordneten Anweisung aufgerufen wird. Die spaltenweise Bindung wird ausgewählt, indem der Wert auf SQL_BIND_BY_COLUMN festgelegt wird. Die zeilenweise Bindung wird ausgewählt, indem der Wert auf die Länge einer Struktur oder auf eine Instanz eines Puffers festgelegt wird, in die Ergebnis Spalten gebunden werden.<br /><br /> Wenn eine Länge angegeben ist, muss Sie Leerzeichen für alle gebundenen Spalten und alle Auffüll Zeichen der Struktur oder des Puffers enthalten, um sicherzustellen, dass das Ergebnis, wenn die Adresse einer gebundenen Spalte mit der angegebenen Länge inkrementiert wird, auf den Anfang derselben Spalte in der-Spalte zeigt. e nächste Zeile. Wenn der **sizeof** -Operator mit Strukturen oder Unions in ANSI C verwendet wird, ist dieses Verhalten garantiert.<br /><br /> Die spaltenweise Bindung ist die Standard Bindungs Ausrichtung für **SQLFetch** und **SQLFetchScroll**.<br /><br /> Weitere Informationen finden Sie unter [Binden von Spalten für die Verwendung mit Block Cursorn](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_BIND_TYPE Feld im ARD-Header festgelegt.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2,0)|Ein SQLULEN-Wert, der die Nummer der aktuellen Zeile im gesamten Resultset ist. Wenn die Nummer der aktuellen Zeile nicht bestimmt werden kann oder keine aktuelle Zeile vorhanden ist, gibt der Treiber 0 zurück.<br /><br /> Dieses Attribut kann durch einen Aufrufen von **SQLGetStmtAttr** abgerufen, aber nicht durch einen-Befehl von **SQLSetStmtAttr**festgelegt werden.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3,0)|Ein sqlusmallint \* -Wert, der auf ein Array von sqlusmallint-Werten verweist, die verwendet werden, um eine Zeile während eines Massen Vorgangs mithilfe von **SQLSetPos**zu ignorieren. Jeder Wert wird entweder auf SQL_ROW_PROCEED (für die Zeile, die in den Massen Vorgang eingeschlossen werden soll) oder SQL_ROW_IGNORE (für die Zeile, die vom Massen Vorgang ausgeschlossen werden soll) festgelegt. (Zeilen können nicht ignoriert werden, indem dieses Array während Aufrufen von **SQLBulkOperations**verwendet wird.)<br /><br /> Dieses Anweisungs Attribut kann auf einen NULL-Zeiger festgelegt werden. in diesem Fall gibt der Treiber keine Zeilen Statuswerte zurück. Dieses Attribut kann jederzeit festgelegt werden, aber der neue Wert wird erst beim nächsten Aufruf von **SQLSetPos** verwendet.<br /><br /> Weitere Informationen finden Sie unter [Aktualisieren von Zeilen im Rowset mit SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) und [Löschen von Zeilen im Rowset mit SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_ARRAY_STATUS_PTR Feld in der ARD festgelegt.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3,0)|Ein sqlusmallint \* -Wert, der auf ein Array von sqlusmallint-Werten zeigt, die nach einem **SQLFetch** -oder **SQLFetchScroll**-Aufrufs Zeilen Statuswerte enthalten. Das Array verfügt über so viele Elemente, wie Zeilen im Rowset vorhanden sind.<br /><br /> Dieses Anweisungs Attribut kann auf einen NULL-Zeiger festgelegt werden. in diesem Fall gibt der Treiber keine Zeilen Statuswerte zurück. Dieses Attribut kann jederzeit festgelegt werden, aber der neue Wert wird erst verwendet, wenn **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**oder **SQLSetPos** aufgerufen wird.<br /><br /> Weitere Informationen finden Sie unter [Anzahl der abgerufenen Zeilen und Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_ARRAY_STATUS_PTR Feld im IRD-Header festgelegt.<br /><br /> Dieses Attribut wird durch einen ODBC *2. x* -Treiber dem *rgbrowstatararray* in einem **SQLExtendedFetch**-Befehl zugeordnet.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3,0)|Ein SQLULEN \* -Wert, der auf einen Puffer zeigt, in den die Anzahl der Zeilen zurückgegeben wird, die nach einem **SQLFetch** -oder **SQLFetchScroll**-Befehl abgerufen werden. die Anzahl der Zeilen, die von einem Massen Vorgang betroffen sind, der durch einen-Befehl von **SQLSetPos** mit einem *Vorgangs* Argument SQL_REFRESH; ausgeführt wird. oder die Anzahl der Zeilen, die von einem von **SQLBulkOperations**ausgeführten Massen Vorgang betroffen sind. Diese Anzahl umfasst Fehler Zeilen.<br /><br /> Weitere Informationen finden Sie unter [Anzahl der abgerufenen Zeilen und Status](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Durch Festlegen dieses Anweisungs Attributs wird das SQL_DESC_ROWS_PROCESSED_PTR Feld im IRD-Header festgelegt.<br /><br /> Wenn der **SQLFetch** -oder **SQLFetchScroll** -Befehl, der den Puffer füllt, auf den dieses Attribut zeigt, keine SQL_SUCCESS oder SQL_SUCCESS_WITH_INFO zurückgibt, ist der Inhalt des Puffers nicht definiert.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2,0)|Ein SQLULEN-Wert, der angibt, ob Treiber, die positionierte UPDATE-und DELETE-Anweisungen simulieren, garantieren, dass diese Anweisungen nur eine einzelne Zeile betreffen.<br /><br /> Um positionierte UPDATE-und DELETE-Anweisungen zu simulieren, erstellen die meisten Treiber eine gesuchte **Update** -oder **Delete** -Anweisung, die eine **Where** -Klausel enthält, die den Wert jeder Spalte in der aktuellen Zeile angibt. Eine solche Anweisung kann nur eine Zeile beeinflussen, wenn diese Spalten einen eindeutigen Schlüssel bilden.<br /><br /> Um sicherzustellen, dass diese Anweisungen nur eine Zeile betreffen, bestimmt der Treiber die Spalten in einem eindeutigen Schlüssel und fügt diese Spalten dem Resultset hinzu. Wenn eine Anwendung sicherstellt, dass die Spalten im Resultset einen eindeutigen Schlüssel bilden, muss der Treiber dies nicht tun. Dies kann die Ausführungszeit verringern.<br /><br /> SQL_SC_NON_UNIQUE = der Treiber garantiert nicht, dass sich simulierte positionierte UPDATE-oder DELETE-Anweisungen nur auf eine Zeile auswirken. die Anwendung ist dafür verantwortlich. Wenn eine-Anweisung mehr als eine Zeile betrifft, gibt **SQLExecute**, **SQLExecDirect**oder **SQLSetPos** SQLSTATE 01001 (Cursor Vorgangs Konflikt) zurück.<br /><br /> SQL_SC_TRY_UNIQUE = der Treiber versucht sicherzustellen, dass simulierte positionierte UPDATE-oder DELETE-Anweisungen nur eine Zeile betreffen. Der Treiber führt diese Anweisungen immer aus, auch wenn Sie sich auf mehr als eine Zeile auswirken können, z. b. Wenn kein eindeutiger Schlüssel vorhanden ist. Wenn eine-Anweisung mehr als eine Zeile betrifft, gibt **SQLExecute**, **SQLExecDirect**oder **SQLSetPos** SQLSTATE 01001 (Cursor Vorgangs Konflikt) zurück.<br /><br /> SQL_SC_UNIQUE = der Treiber garantiert, dass simulierte positionierte UPDATE-oder DELETE-Anweisungen nur eine Zeile betreffen. Wenn der Treiber dies für eine bestimmte Anweisung nicht garantieren kann, gibt **SQLExecDirect** oder **SQLPrepare** einen Fehler zurück.<br /><br /> Wenn die Datenquelle systemeigene SQL-Unterstützung für positionierte UPDATE-und DELETE-Anweisungen bereitstellt und der Treiber keine Cursor simuliert, wird SQL_SUCCESS zurückgegeben, wenn SQL_SC_UNIQUE für SQL_SIMULATE_CURSOR angefordert wird. SQL_SUCCESS_WITH_INFO wird zurückgegeben, wenn SQL_SC_TRY_UNIQUE oder SQL_SC_NON_UNIQUE angefordert wird. Wenn die Datenquelle die SQL_SC_TRY_UNIQUE Unterstützungs Ebene bereitstellt und der Treiber dies nicht bewirkt, wird SQL_SUCCESS für SQL_SC_TRY_UNIQUE zurückgegeben und SQL_SUCCESS_WITH_INFO für SQL_SC_NON_UNIQUE zurückgegeben.<br /><br /> Wenn der angegebene Cursor Simulations Typ von der Datenquelle nicht unterstützt wird, ersetzt der Treiber einen anderen Simulations Typ und gibt SQLSTATE 01s02 (Optionswert geändert) zurück. Bei SQL_SC_UNIQUE ersetzt der Treiber in der richtigen Reihenfolge SQL_SC_TRY_UNIQUE oder SQL_SC_NON_UNIQUE. Bei SQL_SC_TRY_UNIQUE ersetzt der Treiber SQL_SC_NON_UNIQUE.<br /><br /> Der Standardwert ist SQL_SC_UNIQUE.<br /><br /> Weitere Informationen finden Sie unter [Simulieren von positionierten Update-und DELETE-Anweisungen](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2,0)|Ein SQLULEN-Wert, der angibt, ob eine Anwendung Lesezeichen mit einem Cursor verwendet:<br /><br /> SQL_UB_OFF = Off (Standard)<br /><br /> SQL_UB_VARIABLE = eine Anwendung verwendet Lesezeichen mit einem Cursor, und der Treiber stellt Lesezeichen mit variabler Länge bereit, wenn diese unterstützt werden. SQL_UB_FIXED ist in ODBC *3. x*veraltet. ODBC *3. x* -Anwendungen sollten immer Lesezeichen mit variabler Länge verwenden, auch wenn Sie mit ODBC *2. x* -Treibern arbeiten (die nur 4-Byte-Lesezeichen mit fester Länge unterstützen). Dies liegt daran, dass ein Lesezeichen mit fester Länge nur ein Sonderfall eines Lesezeichens variabler Länge ist. Beim Arbeiten mit einem ODBC *2. x* -Treiber ordnet der Treiber-Manager SQL_UB_VARIABLE SQL_UB_FIXED zu.<br /><br /> Um Lesezeichen mit einem Cursor zu verwenden, muss die Anwendung dieses Attribut mit dem SQL_UB_VARIABLE Wert angeben, bevor der Cursor geöffnet wird.<br /><br /> Weitere Informationen finden Sie unter [Abrufen von Lesezeichen](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] diese Funktionen können nur dann asynchron aufgerufen werden, wenn es sich bei dem Deskriptor um einen Implementierungs Deskriptor, nicht um einen Anwendungs Deskriptor handelt.  
  
 Weitere Informationen finden Sie unter [spaltenweise Bindung](../../../odbc/reference/develop-app/column-wise-binding.md) und [Zeilen weises binden](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Verwandte Funktionen  
  
|Informationen über|Finden Sie unter|  
|---------------------------|---------|  
|Abbrechen der Anweisungs Verarbeitung|[SQLCancel-Funktion](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Zurückgeben der Einstellung eines Verbindungs Attributs|[SQLGetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Zurückgeben der Einstellung eines Anweisungs Attributs|[SQLGetStmtAttr-Funktion](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Festlegen eines Verbindungs Attributs|[SQLSetConnectAttr-Funktion](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Festlegen eines einzelnen Felds des Deskriptors|[SQLSetDescField-Funktion](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Weitere Informationen  
 [ODBC-API-Referenz](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [ODBC-Headerdateien](../../../odbc/reference/install/odbc-header-files.md)
